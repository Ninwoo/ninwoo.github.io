<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="研究生不研究“生”，开始研究代码了！">
<meta property="og:type" content="website">
<meta property="og:title" content="NinWoo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="NinWoo">
<meta property="og:description" content="研究生不研究“生”，开始研究代码了！">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NinWoo">
<meta name="twitter:description" content="研究生不研究“生”，开始研究代码了！">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>NinWoo</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bedd7f369d664ca2485e7fe79869f316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NinWoo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">日常学习笔记</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/Spring_Reference(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/Spring_Reference(1)/" itemprop="url">
                  Introduction to the Spring IoC Container and Beans
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-25 23:27:55 / 修改时间：09:43:35" itemprop="dateCreated datePublished" datetime="2018-10-25T23:27:55+08:00">2018-10-25</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/25/Spring_Reference(1)/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/25/Spring_Reference(1)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/25/Spring_Reference(1)/" class="leancloud_visitors" data-flag-title="Introduction to the Spring IoC Container and Beans">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction-to-the-Spring-IoC-Container-and-Beans"><a href="#Introduction-to-the-Spring-IoC-Container-and-Beans" class="headerlink" title="Introduction to the Spring IoC Container and Beans"></a>Introduction to the Spring IoC Container and Beans</h1><p>本章介绍了基于控制反转(IoC)原理的Spring框架实现。IoC也称为依赖注入(dependency injection, DI)。在这个过程中，对象只通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回后设置的属性来定义它们的依赖关系(也就是说，它们使用的其他对象)。然后容器在创建bean时注入这些依赖项。这个过程从根本上说是bean本身的翻转(因此称为控制反转)，它通过使用类或服务定位器模式等机制的直接构造来控制依赖项的实例化或位置。</p>
<blockquote>
<p>这里补充IoC的理解框图</p>
<p><img src="https://images0.cnblogs.com/blog/289233/201501/261421378318292.jpg" alt="传统应用程序示意图"></p>
</blockquote>
<blockquote>
<p><img src="https://i.imgur.com/znZFD3q.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>从这里我们就可以看出，为什么叫做翻转。因为本来客户端负责创建用户类，而现在只需要获取用户类。</p>
</blockquote>
<p><code>org.spring.framework.beans</code>和<code>org.springframework.context</code>是Spring Framework IoC容器的基础。<code>BeanFactory</code>接口提供了一种高级配置机制，能够管理任何类型的对象。<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口。它增加了：</p>
<ul>
<li>更容易与Spring的AOP特性集成</li>
<li>消息资源处理</li>
<li>事件发布</li>
<li>应用程序层特定的context，例如用于web应用程序的WebApplicationContext。</li>
</ul>
<p>简而言之，BeanFactory提供了配置框架和基本功能，而ApplicationContext添加了更多企业特定的功能。ApplicationContext是BeanFactory的一个完整超集，在本章中专门用于描述Spring的IoC容器。有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅BeanFactory。</p>
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、组装和以其他方式管理的对象。另外，bean只是应用程序中的众多对象之一。bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/Spring_Reference(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/Spring_Reference(4)/" itemprop="url">
                  Dependencies
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-25 19:00:19 / 修改时间：09:45:42" itemprop="dateCreated datePublished" datetime="2018-10-25T19:00:19+08:00">2018-10-25</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/25/Spring_Reference(4)/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/25/Spring_Reference(4)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/25/Spring_Reference(4)/" class="leancloud_visitors" data-flag-title="Dependencies">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h1><p>一个典型的企业应用程序不包含单个对象(或Spring术语中的bean)。即使是最简单的应用程序，也有一些对象一起工作，以显示最终用户所看到的一致的应用程序。<br>下一节将解释如何从定义独立的许多bean定义过渡到一个完全实现的应用程序，在这个应用程序中，对象协作以实现目标。</p>
<h2 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h2><p>依赖注入(Dependency injection)是一个过程，在这个过程中，对象只通过构造函数参数、工厂方法的参数或从工厂方法构造或返回的对象实例上设置的属性来定义它们的依赖关系(也就是说，它们工作的其他对象)。然后容器在创建bean时注入这些依赖项。这个过程本质上是bean本身的翻转(因此称为控制翻转)，它通过使用类或服务定位器模式的直接构造来控制其依赖项的实例化或位置。</p>
<p>使用DI原则，代码更简洁，当对象具有依赖关系时，解耦更有效。对象不查找依赖项，也不知道依赖项的位置或类。因此，您的类变得更容易测试，特别是当依赖关系是在接口或抽象基类上时，这允许存根或模拟实现在单元测试中使用。</p>
<p>DI存在于两种主要变体中:基于构造函数的依赖项注入和基于Setter的依赖项注入。</p>
<h3 id="Constructor-based-Dependency-Injection"><a href="#Constructor-based-Dependency-Injection" class="headerlink" title="Constructor-based Dependency Injection"></a>Constructor-based Dependency Injection</h3><p>基于构造函数的DI由容器调用构造函数来完成，该构造函数有许多参数，每个参数都表示依赖关系。调用带有特定参数的静态工厂方法来构造bean几乎是等价的，本文将把参数类似地处理给构造函数和静态工厂方法。下面的例子展示了一个只能通过构造函数注入依赖注入的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    // the SimpleMovieLister has a dependency on a MovieFinder</span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    // a constructor so that the Spring container can inject a MovieFinder</span><br><span class="line">    public SimpleMovieLister(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // business logic that actually uses the injected MovieFinder is omitted...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这个类没有什么特别之处。它是一个POJO，不依赖于容器特定的接口、基类或注释。</p>
<h3 id="Constructor-Argument-Resolution"><a href="#Constructor-Argument-Resolution" class="headerlink" title="Constructor Argument Resolution"></a>Constructor Argument Resolution</h3><p>构造函数参数解析匹配通过使用参数的<strong>类型</strong>来实现。如果bean定义的构造函数参数中不存在潜在的歧义，那么在bean定义中定义构造函数参数的顺序就是在实例化bean时将这些参数提供给适当的构造函数的顺序。考虑以下类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package x.y;</span><br><span class="line"></span><br><span class="line">public class ThingOne &#123;</span><br><span class="line"></span><br><span class="line">    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设ThingTwo和ThingThree类不通过继承关联，则不存在潜在的歧义。因此，下面的配置可以很好地工作，您不需要在元素<code>&lt;constructor-arg/&gt;</code>中显式指定构造函数参数索引或类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;thingTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;thingThree&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;thingTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;thingThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>当引用另一个bean时，类型是已知的，并且可以进行匹配(就像前面的例子那样)。当使用简单类型(如<value>true</value>)时，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型匹配。考虑以下类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package examples;</span><br><span class="line"></span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    // Number of years to calculate the Ultimate Answer</span><br><span class="line">    private int years;</span><br><span class="line"></span><br><span class="line">    // The Answer to Life, the Universe, and Everything</span><br><span class="line">    private String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    public ExampleBean(int years, String ultimateAnswer) &#123;</span><br><span class="line">        this.years = years;</span><br><span class="line">        this.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Constructor argument type matching</strong></p>
<p>在前面的场景中，如果使用type属性显式地指定构造函数参数的类型，容器可以使用与简单类型匹配的类型。如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Constructor argument index</strong></p>
<p>可以使用index属性显式地指定构造函数参数的索引，如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>除了解决多个简单值的模糊性之外，指定索引还可以解决构造函数具有相同类型的两个参数的模糊性问题。</p>
<blockquote>
<p>基于0的指数</p>
</blockquote>
<p><strong>Constructor argument name</strong></p>
<p>您还可以使用构造函数参数名来消除值歧义，如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>请记住，要使这一工作开箱即用，您的代码必须在启用调试标志的情况下进行编译，以便Spring可以从构造函数查找参数名。如果不能或不想使用调试标志编译代码，可以使用@ConstructorProperties JDK注释显式地为构造函数参数命名。然后示例类必须如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package examples;</span><br><span class="line"></span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    // Fields omitted</span><br><span class="line"></span><br><span class="line">    @ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span><br><span class="line">    public ExampleBean(int years, String ultimateAnswer) &#123;</span><br><span class="line">        this.years = years;</span><br><span class="line">        this.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Setter-based-Dependency-Injection"><a href="#Setter-based-Dependency-Injection" class="headerlink" title="Setter-based Dependency Injection"></a>Setter-based Dependency Injection</h3><p>在调用无参数构造函数或无参数静态工厂方法实例化bean之后，容器调用bean上的setter方法就可以实现基于setter的DI。</p>
<p>下面的示例显示了一个只能通过使用纯setter注入进行依赖注入的类。这个类是常规Java。它是一个POJO，不依赖于容器特定的接口、基类或注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    // the SimpleMovieLister has a dependency on the MovieFinder</span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    // a setter method so that the Spring container can inject a MovieFinder</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // business logic that actually uses the injected MovieFinder is omitted...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationContext为其管理的bean支持基于构造函数和基于setter的DI。在通过构造函数方法注入一些依赖项之后，它还支持基于setter的DI。<br>您可以以BeanDefinition的形式配置依赖关系，并将其与PropertyEditor实例一起使用，以将属性从一种格式转换为另一种格式。然而，大多数Spring用户并不直接使用这些类(即通过编程方式)，而是使用XML bean定义、带注释的组件(即用@Component、@Controller等注释的类)或基于java的@Configuration类中的@Bean方法。然后，这些源在内部转换为BeanDefinition实例，并用于加载整个Spring IoC容器实例。</p>
<blockquote>
<h1 id="Constructor-based-or-setter-based-DI"><a href="#Constructor-based-or-setter-based-DI" class="headerlink" title="Constructor-based or setter-based DI?"></a>Constructor-based or setter-based DI?</h1><p>由于可以混合使用基于构造函数和基于setter的DI，因此使用构造函数<strong>处理强制依赖关系</strong>和setter方法或配置方法处理<strong>可选依赖关系</strong>是一个很好的经验法则。注意，在setter方法上使用@Required注释可以使属性成为必需的依赖项。</p>
</blockquote>
<blockquote>
<p>Spring团队通常提倡构造函数注入，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造注入的组件总是以完全初始化的状态返回给客户端(调用)代码。作为补充说明，大量的构造函数参数是一种糟糕的代码味道，这意味着类可能有太多的职责，应该重构，以便更好地处理关注点的适当分离。</p>
</blockquote>
<blockquote>
<p>Setter注入主要应该只用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则，在代码使用依赖项的任何地方都必须执行非空检查。setter注入的一个好处是，setter方法使该类的对象可以稍后重新配置或重新注入。因此，通过JMX MBean进行管理是setter注入的一个引人注目的用例。</p>
</blockquote>
<blockquote>
<p>用对特定类最有意义的DI样式。有时候，在处理没有源代码的第三方类时，会为您做出选择。例如，如果第三方类不公开任何setter方法，那么构造函数注入可能是惟一可用的DI形式。</p>
</blockquote>
<h3 id="Dependency-Resolution-Process"><a href="#Dependency-Resolution-Process" class="headerlink" title="Dependency Resolution Process"></a>Dependency Resolution Process</h3><p>容器执行以下bean依赖项解析:</p>
<ul>
<li>使用描述所有bean的配置元数据创建和初始化ApplicationContext。配置元数据可以由XML、Java代码或注释指定。</li>
<li>对于每个bean，其依赖关系以属性、构造函数参数或静态工厂方法参数的形式表示(如果使用静态工厂方法而不是普通构造函数)。这些依赖项在bean实际创建时提供给bean。</li>
<li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。</li>
<li>值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将字符串格式提供的值转换为所有内置类型，如int、long、string、boolean等。</li>
</ul>
<p>在创建容器时，Spring容器验证每个bean的配置。然而，直到真正创建bean时，才会设置bean属性本身。当创建容器时，将<strong>创建单实例作用域</strong>并设置为预实例化的bean(<strong>默认</strong>)。作用域在Bean作用域中定义。否则，只有在请求bean时才会创建它。创建bean可能会导致创建bean的图，因为创建和分配了bean的依赖项及其依赖项(等等)。请注意，这些依赖项之间的解析不匹配可能出现得较晚——即在第一次创建受影响的bean时。</p>
<p>如果使用主构造函数注入，则可以创建不可解析的循环依赖场景。</p>
<blockquote>
<h1 id="Circular-dependencies"><a href="#Circular-dependencies" class="headerlink" title="Circular dependencies"></a>Circular dependencies</h1><p>例如:类A需要通过构造函数注入的类B实例，类B需要通过构造函数注入的类A实例。如果将类A和类B配置为相互注入的bean，那么Spring IoC容器将在运行时检测到此循环引用，并抛出BeanCurrentlyInCreationException。</p>
</blockquote>
<blockquote>
<p>一种可能的解决方案是编辑由setter而不是构造器配置的一些类的源代码。或者，避免构造函数注入，只使用setter注入。换句话说，尽管不建议使用setter注入配置循环依赖项。</p>
</blockquote>
<blockquote>
<p>与典型的情况(没有循环依赖项)不同的是，Bean A和bean B之间的循环依赖项强制在完全初始化自身之前将一个bean注入另一个bean(典型的鸡和蛋的场景)。</p>
</blockquote>
<p>您通常可以相信Spring会做正确的事情。它在容器装载时检测配置问题，例如对不存在的bean和循环依赖项的引用。在实际创建bean时，Spring尽可能晚地设置属性并解析依赖关系。这意味着，如果在创建该对象或其依赖项时出现问题，那么在以后请求对象时，正确加载的Spring容器可以生成异常——例如，bean由于丢失或无效属性而抛出异常。<strong>某些配置问题可能会延迟可见性</strong>，这就是为什么ApplicationContext实现在默认情况下预实例化单例bean。<br>在实际需要这些bean之前先花一些时间和内存来创建它们，在创建ApplicationContext时(而不是稍后)，您会发现配置问题。您仍然可以覆盖这个默认行为，以便单例bean能够惰性地初始化，而不是被预先实例化。[问题][1]</p>
<p>如果不存在循环依赖项，当一个或多个协作bean被注入到依赖bean中时，每个协作bean在被注入到依赖bean之前都被完全配置好了。这意味着，如果bean A依赖于Bean B，那么在调用bean A上的setter方法之前，Spring IoC容器已经完全配置了Bean B。换句话说，bean被实例化(如果它不是一个预先实例化的单例对象)，它的依赖关系被设置，相关的生命周期方法(例如配置的init方法或InitializingBean回调方法)被调用。</p>
<h3 id="Examples-of-Dependency-Injection"><a href="#Examples-of-Dependency-Injection" class="headerlink" title="Examples of Dependency Injection"></a>Examples of Dependency Injection</h3><p>下面的示例将基于xml的配置元数据用于基于setter的DI。Spring XML配置文件的一小部分指定了一些bean定义，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;!-- setter injection using the nested ref element --&gt;</span><br><span class="line">    &lt;property name=&quot;beanOne&quot;&gt;</span><br><span class="line">        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- setter injection using the neater ref attribute --&gt;</span><br><span class="line">    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了相应的ExampleBean类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    private AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    private YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    public void setBeanOne(AnotherBean beanOne) &#123;</span><br><span class="line">        this.beanOne = beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanTwo(YetAnotherBean beanTwo) &#123;</span><br><span class="line">        this.beanTwo = beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setIntegerProperty(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，声明setter以匹配XML文件中指定的属性。下面的示例使用基于构造函数的DI:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;!-- constructor injection using the nested ref element --&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- constructor injection using the neater ref attribute --&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了相应的ExampleBean类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    private AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    private YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    public ExampleBean(</span><br><span class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;</span><br><span class="line">        this.beanOne = anotherBean;</span><br><span class="line">        this.beanTwo = yetAnotherBean;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean定义中指定的构造函数参数用作ExampleBean的构造函数的参数。</p>
<p>现在考虑这个例子的一个变体，在这个例子中，Spring不是使用构造函数，而是调用静态工厂方法来返回对象的实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; factory-method=&quot;createInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;anotherExampleBean&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了相应的ExampleBean类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    // a private constructor</span><br><span class="line">    private ExampleBean(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // a static factory method; the arguments to this method can be</span><br><span class="line">    // considered the dependencies of the bean that is returned,</span><br><span class="line">    // regardless of how those arguments are actually used.</span><br><span class="line">    public static ExampleBean createInstance (</span><br><span class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;</span><br><span class="line"></span><br><span class="line">        ExampleBean eb = new ExampleBean (...);</span><br><span class="line">        // some other operations...</span><br><span class="line">        return eb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态工厂方法的参数由元素提供，与实际使用的构造函数完全相同。工厂方法返回的类的类型不必与包含静态工厂方法的类的类型相同(尽管在本例中是这样)。实例(非静态)工厂方法可以以一种基本相同的方式使用(除了使用factory-bean属性而不是类属性之外)，因此我们在这里不讨论这些细节。</p>
<blockquote>
<p>在静态工厂类中的静态方法返回的类可以时任意类型的。</p>
</blockquote>
<h2 id="Dependencies-and-Configuration-in-Detail"><a href="#Dependencies-and-Configuration-in-Detail" class="headerlink" title="Dependencies and Configuration in Detail"></a>Dependencies and Configuration in Detail</h2><p>如前一节所述，可以将bean属性和构造函数参数定义为对其他托管bean(协作者)的引用或内联定义的值。为此,Spring基于xml的配置元数据支持其<property>和<construct-arg>元素中的子元素类型。</construct-arg></property></p>
<h3 id="Straight-Values-Primitives-Strings-and-so-on"><a href="#Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="Straight Values (Primitives, Strings, and so on)"></a>Straight Values (Primitives, Strings, and so on)</h3><p>元素的value属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring的转换服务用于将这些值从字符串转换为属性或参数的实际类型。下面的例子显示了正在设置的各种值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setDriverClassName(String) call --&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>下面的示例使用p-namespace来实现更简洁的XML配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">        destroy-method=&quot;close&quot;</span><br><span class="line">        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;</span><br><span class="line">        p:username=&quot;root&quot;</span><br><span class="line">        p:password=&quot;masterkaoli&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的XML更简洁。但是，在运行时而不是在设计时发现拼写错误，除非使用支持在创建bean定义时自动完成属性的IDE(如IntelliJ IDEA或Spring工具套件)。强烈建议提供这种IDE援助。</p>
<p>您还可以配置java.util.Properties实例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mappings&quot;</span><br><span class="line">    class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typed as a java.util.Properties --&gt;</span><br><span class="line">    &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>Spring容器通过使用JavaBeans<code>PropertyEditor</code>机制将<value>元素转化为<code>java.util.Properties</code>实例。这是一个很好的快捷方式，也是Spring团队支持使用嵌套元素而不是value属性样式的少数几个地方之一。</value></p>
<h4 id="The-idref-element"><a href="#The-idref-element" class="headerlink" title="The idref element"></a>The idref element</h4><p>idref元素只是将容器中另一个bean的id(字符串值，而不是引用)传递给&lt;构造函数-arg/&gt;或<property>元素的一种防错方法。</property></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot;&gt;</span><br><span class="line">        &lt;idref bean=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>前面的bean定义片段与下面的片段完全等价(在运行时):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>第一种形式比第二种更可取，因为使用idref标记可以让容器在部署时验证所引用的命名bean实际存在。在第二个变体中，对传递给客户机bean的targetName属性的值不执行验证。只有当客户机bean实际实例化时，才会发现输入错误(最有可能导致致命的结果)。如果客户机bean是多例，那么这种类型和由此产生的异常可能在部署容器很久之后才会被发现。</p>
<blockquote>
<p>4.0 bean XSD不再支持idref元素上的local属性，因为它不再为常规bean引用提供值。升级到4.0架构时，将现有的idref local引用更改为idref bean。</p>
</blockquote>
<p>元素带来价值的一个常见地方(至少在Spring 2.0之前的版本中)是ProxyFactoryBean定义中的AOP拦截器配置。在指定拦截器名称时使用元素可以防止对拦截器ID的拼写错误。</p>
<h3 id="References-to-Other-Beans-Collaborators"><a href="#References-to-Other-Beans-Collaborators" class="headerlink" title="References to Other Beans (Collaborators)"></a>References to Other Beans (Collaborators)</h3><p>ref元素是<construct -arg="">或<property>定义元素中的最后一个元素。在这里，您将bean的指定属性值设置为对容器管理的另一个bean(合作者)的引用。引用的bean是要设置其属性的bean的依赖项，并且在设置属性之前根据需要对其进行初始化(如果合作者是单例bean，则容器可能已经对其进行了初始化)。所有引用最终都是对另一个对象的引用。作用域和验证取决于是否通过bean、本地属性或父属性指定其他对象的ID或名称。</property></construct></p>
<p>通过<ref>标记的bean属性指定目标bean是最通用的形式，允许创建对相同容器或父容器中的任何bean的引用，而不管它是否在相同的XML文件中。bean属性的值可能与目标bean的id属性相同，也可能与目标bean的name属性中的值相同。下面的例子展示了如何使用ref元素:</ref></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ref bean=&quot;someBean&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>通过父属性指定目标bean将创建对当前容器的父容器中的bean的引用。父属性的值可能与目标bean的id属性或目标bean的name属性中的一个值相同。目标bean必须位于当前bean的父容器中。当您有一个容器层次结构，并且希望使用与父bean同名的代理将现有bean包装在父容器中时，您应该主要使用这个bean引用变体。下面展示如何使用<code>parent</code>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in the parent context --&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.something.SimpleAccountService&quot;&gt;</span><br><span class="line">    &lt;!-- insert dependencies as required as here --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in the child (descendant) context --&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;</span><br><span class="line">    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- insert other configuration and dependencies as required here --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>我们要注意如何引用的parent。</p>
<h3 id="Inner-Beans"><a href="#Inner-Beans" class="headerlink" title="Inner Beans"></a>Inner Beans</h3><p><bean>元素在<property>或<constructor-arg>元素中定义了一个内部bean，如下例所示:</constructor-arg></property></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span><br><span class="line">    &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;</span><br><span class="line">            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>内部bean定义不需要定义ID或名称。如果指定，容器不会使用这样的值作为标识符。容器在创建时也会忽略范围标志，因为内部bean总是匿名的，并且总是与外部bean一起创建的。不可能独立访问内部bean，也不可能将它们注入协作bean(而不是封闭bean)中。</p>
<p>一种特例，可以从自定义作用域接收销毁回调——例如，对于单例bean中包含的请求作用域的内部bean。内部bean实例的创建与其包含的bean绑定在一起，但是销毁回调允许它参与请求范围的生命周期。这不是一个常见的场景。内部bean通常只是共享其包含bean的作用域。</p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p><list>、<set>、<map>和<props>元素分别设置Java集合类型列表、集合、映射和属性的属性和参数。下面的例子展示了如何使用它们:</props></map></set></list></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><span class="line">    &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;a list element followed by a reference&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;</span><br><span class="line">            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someSet&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;just some string&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>映射键或值或集值的值也可以是以下任何元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span><br></pre></td></tr></table></figure>
<h4 id="Collection-Merging"><a href="#Collection-Merging" class="headerlink" title="Collection Merging"></a>Collection Merging</h4><p>Spring容器还支持合并集合。应用程序开发人员可以定义父元素<list>、<map>、<set>或<props>元素，并具有子元素<list>、<map>、<set>或<props>元素从父集合继承和覆盖值。也就是说，子集合的值是合并父集合和子集合的元素的结果，子集合元素覆盖父集合中指定的值。</props></set></map></list></props></set></map></list></p>
<p>Spring容器还支持合并集合。应用程序开发人员可以定义父元素<list>、<map>、<set>或<props>元素，并具有子元素<list>、<map>、<set>或<props>元素从父集合继承和覆盖值。也就是说，子集合的值是合并父集合和子集合的元素的结果，子集合元素覆盖父集合中指定的值。</props></set></map></list></props></set></map></list></p>
<p>下面的例子演示了集合合并:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;administrator&quot;&gt;administrator@example.com&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;support&quot;&gt;support@example.com&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">            &lt;!-- the merge is specified on the child collection definition --&gt;</span><br><span class="line">            &lt;props merge=&quot;true&quot;&gt;</span><br><span class="line">                &lt;prop key=&quot;sales&quot;&gt;sales@example.com&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;support&quot;&gt;support@example.co.uk&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;beans&gt;</span><br></pre></td></tr></table></figure>
<p>注意，在子bean定义的adminemail属性的元素上使用<strong>merge=true</strong>属性。当容器解析并实例化子bean时，生成的实例具有adminEmail属性集合，其中包含将子bean的adminemail集合与父组件的adminemail集合合并的结果。下面的清单显示了结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">administrator=administrator@example.com</span><br><span class="line">sales=sales@example.com</span><br><span class="line">support=support@example.co.uk</span><br></pre></td></tr></table></figure>
<p>子属性集合的值集继承了来自父元素<props>的所有属性元素，而子元素的支持值覆盖了父集合中的值。<br>这种合并行为同样适用于<list>、<map>和<set>集合类型。在<list>元素的特定情况下，将维护与列表集合类型(即有序值集合的概念)关联的语义。父列表的值在所有子列表的值之前.对于映射、集合和属性集合类型，不存在排序。因此，对于位于容器内部使用的关联映射、集合和属性实现类型之下的集合类型，没有任何排序语义。</list></set></map></list></props></p>
<h4 id="Limitations-of-Collection-Merging"><a href="#Limitations-of-Collection-Merging" class="headerlink" title="Limitations of Collection Merging"></a>Limitations of Collection Merging</h4><p>不能合并不同的集合类型(例如映射和列表)。如果您确实试图这样做，则会抛出一个适当的异常。merge属性必须在较低的继承子定义上指定。在父集合定义上指定merge属性是多余的，不会导致所需的合并。</p>
<h4 id="Strongly-typed-collection"><a href="#Strongly-typed-collection" class="headerlink" title="Strongly-typed collection"></a>Strongly-typed collection</h4><p>随着Java 5中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明一个集合类型，使其只能包含(例如)字符串元素。如果使用Spring依赖于将强类型集合注入bean，则可以利用Spring的类型转换支持，以便在添加到集合之前将强类型集合实例的元素转换为适当的类型。下面的Java类和bean定义说明了如何做到这一点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;something&quot; class=&quot;x.y.SomeClass&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accounts&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>当为注入准备好某某bean的accounts属性时，强类型映射的元素类型的泛型信息可以通过反射得到。因此，Spring的类型转换基础结构将各种值元素识别为浮点类型，并将字符串值(9.99、2.75和3.99)转换为实际的浮点类型。</p>
<h3 id="Null-and-Empty-String-Values"><a href="#Null-and-Empty-String-Values" class="headerlink" title="Null and Empty String Values"></a>Null and Empty String Values</h3><p>Spring将属性等的空参数视为空字符串。以下基于xml的配置元数据片段将email属性设置为空字符串值(“”)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;ExampleBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上述示例相当于以下Java代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(&quot;&quot;);</span><br></pre></td></tr></table></figure>
<p>元素<null>处理空值。下面的清单显示了一个示例:</null></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;ExampleBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;email&quot;&gt;</span><br><span class="line">        &lt;null/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上述示例相当于以下Java代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(null);</span><br></pre></td></tr></table></figure>
<h3 id="使用p-namespace的XML快捷方式"><a href="#使用p-namespace的XML快捷方式" class="headerlink" title="使用p-namespace的XML快捷方式"></a>使用p-namespace的XML快捷方式</h3><p>p-namespace允许您使用bean元素的属性(而不是嵌套的<property>元素)来描述您的属性值协作bean，或者两者都使用。</property></p>
<p>Spring支持具有名称空间的可扩展配置格式，名称空间基于XML模式定义。本章讨论的bean配置格式在XML模式文档中被定义。但是，p-namespace不在XSD文件中定义，只存在于Spring的核心中。</p>
<p>下面的示例显示了两个解析为相同结果的XML片段(第一个使用标准XML格式，第二个使用p-namespace):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;</span><br><span class="line">        p:email=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>这个例子显示了bean定义中称为email的p命名空间中的一个属性。这告诉Spring包含属性声明。如前所述，p-namespace没有模式定义，因此可以将属性名(attribute)设置为成员变量名。</p>
<p>下一个示例包含另外两个bean定义，它们都引用另一个bean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-modern&quot;</span><br><span class="line">        class=&quot;com.example.Person&quot;</span><br><span class="line">        p:name=&quot;John Doe&quot;</span><br><span class="line">        p:spouse-ref=&quot;jane&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>这个示例不仅包含使用p-namespace的属性值，还使用特殊格式声明属性引用。第一个bean定义使用<property name="spouse" ref="jane">来创建bean john到bean jane的引用，而第二个bean定义使用p:spouse-ref=”jane”作为属性来做同样的事情。在本例中，<code>spouse</code>是属性名，而<code>-ref</code>部分指示这不是一个直接值，而是对另一个bean的引用。</property></p>
<blockquote>
<p>p-namespace不像标准XML格式那样灵活。例如，声明属性引用的格式与以Ref结尾的属性冲突，而标准XML格式则不同。我们建议您仔细选择您的方法，并与您的团队成员进行沟通，以避免生成同时使用这三种方法的XML文档。</p>
</blockquote>
<h3 id="XML-Shortcut-with-the-c-namespace"><a href="#XML-Shortcut-with-the-c-namespace" class="headerlink" title="XML Shortcut with the c-namespace"></a>XML Shortcut with the c-namespace</h3><p>与使用p-namespace的XML快捷方式类似，Spring 3.1中引入的c-namespace允许内联属性配置构造函数参数，而不是嵌套构造函数-arg元素。</p>
<p>下面的示例使用<code>c:</code>命名空间来做与基于构造函数的依赖注入相同的事情:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;thingTwo&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- traditional declaration --&gt;</span><br><span class="line">    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;thingTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;thingThree&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg value=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- c-namespace declaration --&gt;</span><br><span class="line">    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;thingTwo&quot; c:thingThree-ref=&quot;thingThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>命名空间使用与p: one (bean引用的结尾-ref)相同的约定来设置构造函数参数的名称。同样，需要声明它，即使它没有在XSD模式中定义(它存在于Spring核心中)。</p>
<p>对于很少出现的构造函数参数名不可用的情况(通常是在编译字节码时没有调试信息的情况下)，您可以使用回退参数索引，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- c-namespace index declaration --&gt;</span><br><span class="line">&lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;thingTwo&quot; c:_1-ref=&quot;thingThree&quot;/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于XML语法的原因，索引符号需要有前导_，因为XML属性名不能以数字开头(尽管某些ide允许这样做)。</p>
</blockquote>
<h3 id="Compound-Property-Names"><a href="#Compound-Property-Names" class="headerlink" title="Compound Property Names"></a>Compound Property Names</h3><p>在设置bean属性时，可以使用复合属性名或嵌套属性名，只要路径中除最终属性名之外的所有组件不为空。考虑下面的bean定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;something&quot; class=&quot;things.ThingOne&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>something bean有一个fred属性，bob属性，sammy属性，最后的sammy属性被设置为123。为了使其工作，在构建bean之后，fred属性和bob属性必须不为空。否则，将抛出NullPointerException。</p>
<h2 id="Using-depends-on"><a href="#Using-depends-on" class="headerlink" title="Using depends-on"></a>Using depends-on</h2><p>译文：如果一个bean是另一个bean的依赖关系，这通常意味着一个bean被设置为另一个bean的属性。通常，您可以使用基于xml的配置元数据中的元素来完成此任务。然而，有时候bean之间的依赖关系不那么直接。例如，类中的静态初始化器需要触发，例如数据库驱动程序注册。<strong>依赖属性可以显式地强制在初始化使用此元素的bean之前初始化一个或多个bean</strong>。下面的示例使用depends-on属性来表示对单个属性的依赖性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>了表示对多个bean的依赖关系，提供一个bean名称列表作为依赖关系属性的值(逗号、空格和分号是有效的分隔符):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>注意:bean定义中的depends-on属性既可以指定initialization-time关系，也可以指定仅在单例bean中对应的destroy-time依赖关系。定义与给定bean之间依赖关系的依赖bean首先被销毁，然后再销毁给定bean本身。因此，依赖也可以控制关机顺序。</p>
<blockquote>
<p>简单说就是调用别的先销毁，然后被调用的在销毁。</p>
</blockquote>
<h2 id="Lazy-initialized-Beans"><a href="#Lazy-initialized-Beans" class="headerlink" title="Lazy-initialized Beans"></a>Lazy-initialized Beans</h2><p><strong>默认情况下，ApplicationContext实现在初始化过程中急切地创建和配置所有单例bean。</strong>通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几个小时甚至几天之后。</p>
<p>[1]: 为什么要选择用单例： <a href="https://docs.spring.io/spring/docs/5.1.1.RELEASE/spring-framework-reference/core.html#beans-dependency-resolution" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.1.1.RELEASE/spring-framework-reference/core.html#beans-dependency-resolution</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/Spring_Reference(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/Spring_Reference(2)/" itemprop="url">
                  Container Overview
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-25 18:59:19 / 修改时间：09:44:36" itemprop="dateCreated datePublished" datetime="2018-10-25T18:59:19+08:00">2018-10-25</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/25/Spring_Reference(2)/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/25/Spring_Reference(2)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/25/Spring_Reference(2)/" class="leancloud_visitors" data-flag-title="Container Overview">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Container-Overview"><a href="#Container-Overview" class="headerlink" title="Container Overview"></a>Container Overview</h1><p><code>org.springframework.context.ApplicationContext</code>接口代表Spring IoC容器，并负责实例化、配置和组装bean。容器通过读取配置元数据获得关于实例化、配置和组装对象的指令。配置元数据用XML、Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间的丰富相互依赖关系。</p>
<p>Spring提供了ApplicationContext接口的几个实现。在独立应用程序中，通常创建<code>ClassPathXmlApplicationContext</code>或<code>FileSystemXmlApplicationContext</code>实例。虽然XML一直是定义配置元数据的传统格式，但您可以通过提供少量XML配置来声明支持这些额外的元数据格式，指示容器使用Java注释或代码作为元数据格式。</p>
<p>在大多数应用程序场景中，不需要显式用户代码来实例化Spring IoC容器的一个或多个实例。例如，在web应用程序场景中，应用程序的web.xml文件中的8行(或大约8行)样板web描述符XML通常就足够了.</p>
<p>如果您使用Spring工具套件(一个eclipse驱动的开发环境)，您可以很容易地通过单击鼠标或击键创建这个样板配置。</p>
<p>下图显示了Spring工作原理的高级视图。您的应用程序类与配置元数据相结合，这样在创建和初始化ApplicationContext之后，您就有了一个完整配置的可执行系统或应用程序。</p>
<p><img src="https://docs.spring.io/spring/docs/5.1.1.RELEASE/spring-framework-reference/images/container-magic.png" alt="The Spring IoC container"></p>
<h2 id="Configuration-Metadata"><a href="#Configuration-Metadata" class="headerlink" title="Configuration Metadata"></a>Configuration Metadata</h2><p>如上面的图表所示，Spring IoC容器使用了一种配置元数据的形式。这个配置元数据表示您作为应用程序开发人员如何告诉Spring容器实例化、配置和组装应用程序中的对象。</p>
<p>配置元数据传统上以简单直观的XML格式提供，这是本章的主要内容，用于传递Spring IoC容器的关键概念和特性。</p>
<blockquote>
<p>基于xml的元数据不是配置元数据的唯一允许形式。Spring IoC容器本身与实际编写配置元数据的格式完全分离。现在，许多开发人员为他们的Spring应用程序选择基于java的配置。</p>
</blockquote>
<p>有关使用Spring容器的其他元数据形式的信息，请参阅:</p>
<ul>
<li>Annotation-based configuration: Spring 2.5引入了对基于注释的配置元数据的支持。</li>
<li>Java-based configuration: 从Spring 3.0开始，Spring JavaConfig项目提供的许多特性成为核心Spring框架的一部分。因此，您可以通过使用Java而不是XML文件来定义应用程序类外部的bean。要使用这些新特性，请参阅@Configuration、@Bean、@Import和@DependsOn注释。</li>
</ul>
<p>Spring配置包含至少一个bean定义，通常是容器必须管理的多个bean定义。基于xml的配置元数据将这些bean配置为顶层元素中的元素。基于xml的配置元数据将这些bean配置为顶层<beans>元素中的<bean>元素。Java配置通常在@Configuration类中使用@ bean注释的方法。</bean></beans></p>
<p>这些bean定义对应于组成应用程序的实际对象。通常，您可以定义服务层对象、数据访问对象(DAOs)、表示对象(如Struts动作实例)、基础设施对象(如Hibernate SessionFactories)、JMS队列等。通常，在容器中不配置细粒度的域对象，因为创建和加载域对象通常是dao和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。</p>
<p>下面的例子展示了基于xml的配置元数据的基本结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>id:i是标识单个bean定义的字符串。</li>
<li>class:定义bean的类型并使用完全限定的classname。</li>
</ul>
<p>id属性的值引用协作对象。本例中没有显示引用协作对象的XML。有关更多信息，请参见依赖关系。</p>
<h2 id="Instantiating-a-Container"><a href="#Instantiating-a-Container" class="headerlink" title="Instantiating a Container"></a>Instantiating a Container</h2><p>提供给ApplicationContext构造函数的位置路径或路径是资源字符串，允许容器装载来自各种外部资源(如本地文件系统、Java类路径等)的配置元数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</span><br></pre></td></tr></table></figure>
<p>注意:在了解了Spring的IoC容器之后，您可能想了解更多关于Spring的资源抽象(如参考资料中所述)的内容，它提供了从URI语法中定义的位置读取InputStream的方便机制。特别是，资源路径用于构造应用程序上下文，正如在应用程序上下文和资源路径中描述的那样。</p>
<p>下面的示例显示了服务层对象(service .xml)配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- services --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;petStore&quot; class=&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;itemDao&quot; ref=&quot;itemDao&quot;/&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions for services go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>下面的示例显示了数据访问对象daos.xml文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;accountDao&quot;</span><br><span class="line">        class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;itemDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，服务层包含PetStoreServiceImpl类和JpaAccountDao和JpaItemDao类型的两个数据访问对象(基于JPA对象关系映射标准)。</p>
<p>属性名称元素引用JavaBean属性的名称，ref元素引用另一个bean定义的名称。id和ref元素之间的链接表示协作对象之间的依赖关系。有关配置对象依赖项的详细信息，请参阅依赖项。</p>
<h3 id="Composing-XML-based-Configuration-Metadata"><a href="#Composing-XML-based-Configuration-Metadata" class="headerlink" title="Composing XML-based Configuration Metadata"></a>Composing XML-based Configuration Metadata</h3><p>让bean定义跨越多个XML文件可能很有用。通常，每个XML配置文件都代表体系结构中的逻辑层或模块。</p>
<p>您可以使用Application context构造函数从所有这些XML片段加载bean定义。此构造函数接受多个资源位置，如前一节所示。或者，使用一个或多个元素来从另一个或多个文件加载bean定义。下面的例子展示了如何做到这一点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;import resource=&quot;services.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，外部bean定义从三个文件加载:service.xml,messageSource.xml和themeSource.xml。</p>
<p>所有位置路径都相对于执行导入操作的定义文件，因此是service.xml必须与执行导入的文件位于相同的目录或classpath位置，而messageSource.xml和themeSource.xml必须位于导入文件位置下方的resources位置。如您所见，前导斜杠被忽略。但是，考虑到这些路径是相对的，最好不要使用斜杠。根据Spring模式，导入的文件的内容，包括顶层元素，必须是有效的XML bean定义。</p>
<blockquote>
<p>可以，但不推荐，引用文件在父目录使用一个相对”../”路径。这样做会对当前应用程序之外的文件创建依赖关系。特别是，不建议将此引用用于classpath: URLs(例如，classpath:../services.xml)，其中运行时解析过程选择“最近的”classpath根目录，然后查看它的父目录。类路径配置更改可能导致选择不同的、不正确的目录。</p>
<p>您总是可以使用完全限定的资源位置而不是相对路径:例如，文件:C:/config/services。xml或者类路径:/配置/ services . xml。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。对于这样的绝对位置，通常最好保持间接——例如，通过在运行时针对JVM系统属性解析的“${…}”占位符。</p>
</blockquote>
<p>命名空间本身支持import directive特性。在Spring提供的XML名称空间(例如context和util名称空间)中，除了普通bean定义之外，还有其他配置特性。</p>
<h3 id="The-Groovy-Bean-Definition-DSL"><a href="#The-Groovy-Bean-Definition-DSL" class="headerlink" title="The Groovy Bean Definition DSL"></a>The Groovy Bean Definition DSL</h3><p>作为外部化配置元数据的进一步示例，bean定义也可以在Spring的Groovy bean定义DSL中表示，从Grails框架中可以知道这一点。通常，这样的配置位于”.groovy”中。结构如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">beans &#123;</span><br><span class="line">    dataSource(BasicDataSource) &#123;</span><br><span class="line">        driverClassName = &quot;org.hsqldb.jdbcDriver&quot;</span><br><span class="line">        url = &quot;jdbc:hsqldb:mem:grailsDB&quot;</span><br><span class="line">        username = &quot;sa&quot;</span><br><span class="line">        password = &quot;&quot;</span><br><span class="line">        settings = [mynew:&quot;setting&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory(SessionFactory) &#123;</span><br><span class="line">        dataSource = dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    myService(MyService) &#123;</span><br><span class="line">        nestedBean = &#123; AnotherBean bean -&gt;</span><br><span class="line">            dataSource = dataSource</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种配置样式基本上与XML bean定义等价，甚至支持Spring的XML配置名称空间。它还允许通过importBeans指令导入XML bean定义文件。</p>
<h3 id="Using-the-Container"><a href="#Using-the-Container" class="headerlink" title="Using the Container"></a>Using the Container</h3><p>ApplicationContext是一个高级工厂的接口，能够维护不同bean及其依赖项的注册表。通过使用方法T getBean(String name, Class<t> requiredType)，您可以获取bean的实例。</t></p>
<p>ApplicationContext允许您读取bean定义并访问它们，如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// create and configure beans</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</span><br><span class="line"></span><br><span class="line">// retrieve configured instance</span><br><span class="line">PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);</span><br><span class="line"></span><br><span class="line">// use configured instance</span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>
<p>使用Groovy配置，bootstrapping看起来非常相似。它有一个不同的context实现类，它支持groovy-aware(但也理解XML bean定义)。下面的示例展示了Groovy配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);</span><br></pre></td></tr></table></figure>
<p>最灵活的变体是GenericApplicationContext和reader delegate相结合——例如，XmlBeanDefinitionReader用于XML文件，如下示例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
<p>您还可以为Groovy文件使用GroovyBeanDefinitionReader，如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
<p>您可以在相同的ApplicationContext上混合并匹配这样的读取器委托，从不同的配置源读取bean定义。</p>
<p>然后，可以使用getBean检索bean的实例。ApplicationContext接口有一些用于检索bean的其他方法，但理想情况下，应用程序代码不应该使用它们。实际上，您的应用程序代码根本不应该调用getBean()方法，因此根本不需要依赖Spring api。例如，Spring与web框架的集成为各种web框架组件(如控制器和jsf管理的bean)提供了依赖注入，允许您通过元数据(如自动连接注释)声明对特定bean的依赖</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/Spring_Reference(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/Spring_Reference(3)/" itemprop="url">
                  Bean Overview
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-25 18:59:19 / 修改时间：09:45:06" itemprop="dateCreated datePublished" datetime="2018-10-25T18:59:19+08:00">2018-10-25</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/25/Spring_Reference(3)/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/25/Spring_Reference(3)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/25/Spring_Reference(3)/" class="leancloud_visitors" data-flag-title="Bean Overview">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bean-Overview"><a href="#Bean-Overview" class="headerlink" title="Bean Overview"></a>Bean Overview</h1><p>Spring IoC容器管理一个或多个bean。这些bean是使用提供给容器的配置元数据创建的(例如，XML 定义的形式)。</p>
<p>在容器本身中，这些bean定义被表示为<code>BeanDefinition</code>对象，其中包含以下元数据(以及其他信息):</p>
<ul>
<li>包限定类名:通常是定义的bean的实际实现类。</li>
<li>Bean行为配置元素，它说明Bean在容器中的行为(范围、生命周期回调等等)。</li>
<li>对bean执行其工作所需的其他bean的引用。这些引用也称为协作者或依赖关系。</li>
<li>在新创建的对象中要设置的其他配置设置——例如，池的大小限制或管理连接池的bean中要使用的连接数。</li>
</ul>
<p>此元数据转换为组成每个bean定义的一组属性。下表描述了这些属性:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Explained in…</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td>实例化Bean</td>
</tr>
<tr>
<td>Name</td>
<td>命名Beans</td>
</tr>
<tr>
<td>Scope</td>
<td>Bean生成期</td>
</tr>
<tr>
<td>Contructor arguments</td>
<td>依赖注入</td>
</tr>
<tr>
<td>Properties</td>
<td>依赖注入</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>自动装配合作者</td>
</tr>
<tr>
<td>Lazy initialization mdoe</td>
<td>初始化回调</td>
</tr>
<tr>
<td>Destruction method</td>
<td>毁坏回调</td>
</tr>
</tbody>
</table>
<p>除了包含关于如何创建特定bean的信息的bean定义之外，ApplicationContext实现还允许注册容器之外创建的现有对象(由用户创建)。<br>通过getBeanFactory()方法访问ApplicationContext的BeanFactory，该方法返回BeanFactory DefaultListableBeanFactory实现。DefaultListableBeanFactory通过registerSingleton(..)和registerBeanDefinition(..)方法支持此注册。但是，典型的应用程序只使用通过元数据bean定义定义的bean。</p>
<blockquote>
<p>Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动连接和其他自省步骤期间正确地推断它们。虽然在一定程度上支持覆盖现有的元数据和现有的单例实例，但是在运行时注册新bean(与对工厂的实时访问同时进行)并没有得到正式支持，并且可能导致并发访问异常、bean容器中的不一致状态，或者两者都有。</p>
</blockquote>
<h2 id="Naming-Beans"><a href="#Naming-Beans" class="headerlink" title="Naming Beans"></a>Naming Beans</h2><p>每个bean都有一个或多个标识符。这些标识符在承载bean的容器中必须是唯一的。bean通常只有一个标识符。但是，如果需要一个以上的别名，则可以将额外的别名看作别名。</p>
<p>在基于xml的配置元数据中，可以使用id属性、name属性或两者来指定bean标识符。id属性允许您指定一个id。按照惯例，这些名称是字母数字(“myBean”、“someService”等)，但它们也可以包含特殊字符。如果希望为bean引入其他别名，还可以在name属性中指定它们，用逗号(、)、分号(;)或空格分隔。作为历史记录，在Spring 3.1之前的版本中，id属性被定义为xsd: id类型，这限制了可能的字符。在3.1中，它被定义为xsd:string类型。请注意，bean id惟一性仍然由容器强制执行，但不再由XML解析器强制执行。</p>
<p>您不需要为bean提供名称或id。如果没有显式地提供名称或id，容器将为该bean生成唯一的名称。但是，如果希望通过引用ref元素或服务定位器样式查找来引用bean的名称，则必须提供名称。<strong>不提供名称的动机与使用内部bean和自动连接合作者有关。</strong></p>
<blockquote>
<h1 id="Bean-命名约定"><a href="#Bean-命名约定" class="headerlink" title="Bean 命名约定"></a>Bean 命名约定</h1><p>约定是在命名bean时使用标准Java约定作为实例字段名。也就是说，bean名称以小写字母开头，然后以驼色大小写字母开头。这些名字的例子包括accountManager，accountService, userDao, loginController, 等等。</p>
</blockquote>
<blockquote>
<p>一致地命名bean使您的配置更容易阅读和理解。另外，如果您使用Spring AOP，那么在向一组名称相关的bean应用建议时，它会有很大帮助。</p>
</blockquote>
<hr>
<blockquote>
<p>注：通过类路径中的组件扫描，Spring为未命名的组件生成bean名称，遵循前面描述的规则:本质上，使用简单的类名并将其初始字符转换为小写。然而，在(不寻常的)特殊情况下，当有一个以上的字符，并且第一和第二字符都是大写字母时，原始的大小写保留。这些规则与<br><code>java.beans.Introspector.decapitalize</code>(此处使用Spring)定义的规则相同。</p>
</blockquote>
<h3 id="Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="Aliasing a Bean outside the Bean Definition"></a>Aliasing a Bean outside the Bean Definition</h3><p>在bean定义本身中，通过使用id属性指定的最多一个名称和name属性中任意数量的其他名称的组合，可以为bean提供多个名称。这些名称可以等效于同一bean的别名，并且在某些情况下非常有用，例如让应用程序中的每个组件通过使用特定于该组件本身的bean名称引用公共依赖项。</p>
<p>然而，指定bean实际定义的所有别名并不总是足够的。<br>有时需要为其他地方定义的bean引入别名。在大型系统中，配置通常在每个子系统之间进行分配，每个子系统都有自己的一组对象定义。在基于xml的配置元数据中，可以使用元素来完成此任务。下面的例子展示了如何做到这一点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，命名为fromName的bean(在同一个容器中)也可以在使用这个别名定义之后称为toName。<br>例如，子系统A的配置元数据可以通过subsystemA-dataSource的名称引用数据源。子系统B的配置元数据可以通过subsystemB-dataSource的名称引用数据源。在组合使用这两个子系统的主应用程序时，主应用程序以myApp-dataSource的名称引用数据源。要使所有三个名称都指向同一个对象，可以向配置元数据添加以下别名定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;alias name=&quot;subsystemA-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;subsystemA-dataSource&quot; alias=&quot;myApp-dataSource&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>现在，每个组件和主应用程序都可以通过唯一的名称引用数据源，并且保证不会与任何其他定义冲突(有效地创建名称空间)，但是它们引用的是同一个bean。</p>
<blockquote>
<h1 id="Java-Configuration"><a href="#Java-Configuration" class="headerlink" title="Java-Configuration"></a>Java-Configuration</h1><p>如果使用Javaconfiguration，那么可以使用@Bean注释来提供别名。有关详细信息，请参阅使用@Bean注释。</p>
</blockquote>
<h3 id="Instantiating-Beans"><a href="#Instantiating-Beans" class="headerlink" title="Instantiating Beans"></a>Instantiating Beans</h3><p>bean定义本质上是创建一个或多个对象的配方。容器在请求时查看命名bean的配方，并使用该bean定义封装的配置元数据来创建(或获取)实际对象。</p>
<p>如果使用基于xml的配置元数据，则指定要在元素<bean>的class属性中实例化的对象的类型(或类)。这个类属性(在内部是BeanDefinition实例上的类属性)通常是强制的。(对于异常，请参阅使用实例工厂方法和Bean定义继承进行实例化。)您可以通过以下两种方式之一来使用类属性:</bean></p>
<ul>
<li>通常，在容器本身通过反射性地调用其构造函数直接创建bean的情况下，指定要构造的bean类，这在某种程度上类似于使用new操作符的Java代码。</li>
<li>在不太常见的情况下，在容器调用类上的静态工厂方法来创建bean时，指定包含用于创建对象的静态工厂方法的实际类。从静态工厂方法调用返回的对象类型可能完全是同一个类或另一个类。</li>
</ul>
<blockquote>
<p>Inner class names<br>如果要为静态嵌套类配置bean定义，则必须使用嵌套类的二进制名称。</p>
</blockquote>
<blockquote>
<p>例如，如果在com.example中有一个名为SomeThing的类。这个SomeThing类有一个名为OtherThing的静态嵌套类，bean定义上的class属性的值应该是com.example.SomeThing$OtherThing。</p>
</blockquote>
<blockquote>
<p>注意，在名称中使用$字符将嵌套类名称与外部类名称分隔开来。</p>
</blockquote>
<h3 id="Instantiation-with-a-Constructor"><a href="#Instantiation-with-a-Constructor" class="headerlink" title="Instantiation with a Constructor"></a>Instantiation with a Constructor</h3><p>当您使用构造函数方法创建bean时，所有普通类都可以使用，并且与Spring兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。简单地<strong>指定</strong>bean类就足够了。然而，根据对特定bean使用的IoC类型的不同，您可能<strong>需要一个默认(空)构造函数</strong>。</p>
<p>Spring IoC容器实际上<strong>可以管理您希望它管理的任何类</strong>。它不限于管理真正的JavaBeans。大多数Spring用户更喜欢实际的javaBeans，只有一个默认的(无参数的)构造函数，以及根据容器中的属性建模的适当的setter和getter。您还可以在容器中拥有更多具有外来的非bean风格的类。例如，如果您需要使用一个完全不遵守JavaBean规范的遗留连接池，Spring也可以对其进行管理。</p>
<p>使用基于xml的配置元数据，您可以如下所示指定bean类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name=&quot;anotherExample&quot; class=&quot;examples.ExampleBeanTwo&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>有关向构造函数提供参数(如果需要)和在构造对象之后设置对象实例属性的机制的详细信息，请参见注入依赖项。</p>
<h3 id="Instantiation-with-a-Static-Factory-Method"><a href="#Instantiation-with-a-Static-Factory-Method" class="headerlink" title="Instantiation with a Static Factory Method"></a>Instantiation with a Static Factory Method</h3><p>在定义使用静态工厂方法创建的bean时，使用class属性指定包含静态工厂方法的类和名为factory-method的属性来指定工厂方法本身的名称。您应该能够调用这个方法(使用可选参数，稍后将进行描述)，并返回一个活动对象，该对象随后将被视为通过构造函数创建的对象。这种bean定义的一种用法是在遗留代码中调用静态工厂。</p>
<p>下面的bean定义指定通过调用工厂方法创建bean。定义没有指定返回对象的类型(类)，只指定包含工厂方法的类。在本例中，createInstance()方法必须是一个静态方法。下面的例子展示了如何指定工厂方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    class=&quot;examples.ClientService&quot;</span><br><span class="line">    factory-method=&quot;createInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>下面的示例显示了一个将与前面的bean定义一起工作的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private ClientService() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ClientService createInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关向工厂方法提供(可选的)参数以及在从工厂返回对象后设置对象实例属性的机制的详细信息，请参阅依赖项和配置的详细信息。</p>
<h3 id="Instantiation-by-Using-an-Instance-Factory-Method"><a href="#Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="Instantiation by Using an Instance Factory Method"></a>Instantiation by Using an Instance Factory Method</h3><p>与通过静态工厂方法实例化类似，使用实例工厂方法实例化从容器调用现有bean的非静态方法来创建新的bean。要使用这种机制，请保持<strong>类属性为空</strong>，并在factory-bean属性中指定当前(或父或祖先)容器中的bean的名称，该容器包含要调用来创建对象的实例方法。使用工厂方法属性设置工厂方法本身的名称。下面的示例展示了如何配置这样的bean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span><br><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the bean to be created via the factory bean --&gt;</span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了相应的Java类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个工厂类也可以容纳多个工厂方法，如下例所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了相应的Java类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AccountService createAccountServiceInstance() &#123;</span><br><span class="line">        return accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法表明，可以通过依赖注入(dependency injection)对工厂bean本身进行管理和配置。请参阅详细的依赖关系和配置。</p>
<blockquote>
<p>在Spring文档中，”factory bean”指的是在Spring容器中配置并通过实例或静态工厂方法创建对象的bean。相比之下，FactoryBean(注意大写)指特定于spring的FactoryBean。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/14/Springr学习笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/14/Springr学习笔记3/" itemprop="url">
                  Springr学习笔记3——事件处理类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-14 22:04:37 / 修改时间：22:49:01" itemprop="dateCreated datePublished" datetime="2018-10-14T22:04:37+08:00">2018-10-14</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/14/Springr学习笔记3/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/14/Springr学习笔记3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/14/Springr学习笔记3/" class="leancloud_visitors" data-flag-title="Springr学习笔记3——事件处理类">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="Spring中的事件处理"><a href="#Spring中的事件处理" class="headerlink" title="Spring中的事件处理"></a>Spring中的事件处理</h2><p><strong>ApplicationContext</strong> 是Spring的核心模块，管理着Beans完整的生命周期。当加载Bean时，ApplicationContext会发布特定类型的事件。<br>eg:当Context启动时ContextStartEvent被发布，当关闭时，ContextStoppedEvent被发布。</p>
<p>ApplicationContext事件处理被ApplicationEvent类和ApplicationListener接口提供。因此，实现了ApplicationListener的bean，每次ApplicationContext发布ApplicationEvent时，Bean将会被通知。</p>
<h3 id="Spring内建事件"><a href="#Spring内建事件" class="headerlink" title="Spring内建事件"></a>Spring内建事件</h3><ul>
<li><strong>ContextRefreshedEvent</strong> : 当ApplicationContext被初始化或者刷新时被发布。也可以通过调用ConfigurableApplicationContext接口的refresh()函数发起。</li>
<li><strong>ContextStartedEvent</strong> : 当Application使用ConfigurableApplicationContext的start()方法启动时被发布。您可以轮询您的数据库，也可以在收到此事件后重新启动任何已停止的应用程序。</li>
<li><strong>ContextStoppedEvent</strong> : 当ApplicationContext在ConfigurableApplicationContext接口上使用stop()方法停止时，就会发布这个事件。你可以在收到这个活动后做家务。</li>
<li><strong>ContextClosedEvent</strong> : 当使用ConfigurableApplicationContext接口上的close()方法关闭ApplicationContext时，将发布此事件。一个封闭的环境到达了生命的终点;不能刷新或重新启动。</li>
<li><strong>RequestHandledEvent</strong> : 这是一个特定于web的事件，它告诉所有bean HTTP请求已经得到了服务。</li>
</ul>
<p>Spring的事件处理是单线程的，因此如果发布了一个事件，直到并且除非所有接收者都得到消息，否则进程将被阻塞，线程将不会继续。因此，如果要使用事件处理，那么在设计应用程序时应该小心。</p>
<h3 id="监听Context事件"><a href="#监听Context事件" class="headerlink" title="监听Context事件"></a>监听Context事件</h3><p>要想监听一个context事件，bean需要实现仅有一个方法onApplicationEvent()的ApplicationListener接口</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>HelloWorld.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">   private String message;</span><br><span class="line"></span><br><span class="line">   public void setMessage(String message)&#123;</span><br><span class="line">      this.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage()&#123;</span><br><span class="line">      System.out.println(&quot;Your Message : &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CStartEventHandler.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CStartEventHandler </span><br><span class="line">   implements ApplicationListener&lt;ContextStartedEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">   public void onApplicationEvent(ContextStartedEvent event) &#123;</span><br><span class="line">      System.out.println(&quot;ContextStartedEvent Received&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CStopEventHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CStopEventHandler </span><br><span class="line">   implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">   public void onApplicationEvent(ContextStoppedEvent event) &#123;</span><br><span class="line">      System.out.println(&quot;ContextStoppedEvent Received&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ConfigurableApplicationContext context = </span><br><span class="line">         new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">      // Let us raise a start event.</span><br><span class="line">      context.start();</span><br><span class="line">	  </span><br><span class="line">      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">      obj.getMessage();</span><br><span class="line"></span><br><span class="line">      // Let us raise a stop event.</span><br><span class="line">      context.stop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Beans</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = &quot;helloWorld&quot; class = &quot;com.tutorialspoint.HelloWorld&quot;&gt;</span><br><span class="line">      &lt;property name = &quot;message&quot; value = &quot;Hello World!&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = &quot;cStartEventHandler&quot; class = &quot;com.tutorialspoint.CStartEventHandler&quot;/&gt;</span><br><span class="line">   &lt;bean id = &quot;cStopEventHandler&quot; class = &quot;com.tutorialspoint.CStopEventHandler&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContextStartedEvent Received</span><br><span class="line">Your Message : Hello World!</span><br><span class="line">ContextStoppedEvent Received</span><br></pre></td></tr></table></figure>
<h2 id="自定义Spring事件"><a href="#自定义Spring事件" class="headerlink" title="自定义Spring事件"></a>自定义Spring事件</h2><p>下边的案例将讲述如何编写和发布你自己的自定义事件</p>
<p>添加自定义事件<code>CustomEvent.java</code>,继承ApplicationEvent类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CustomEvent extends ApplicationEvent&#123;</span><br><span class="line">   public CustomEvent(Object source) &#123;</span><br><span class="line">      super(source);</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return &quot;My Custom Event&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加自定义事件发布类<code>CustomEventPublisher.java</code>，实现ApplicationEventPublisherAware接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CustomEventPublisher implements ApplicationEventPublisherAware &#123;</span><br><span class="line">   private ApplicationEventPublisher publisher;</span><br><span class="line">   </span><br><span class="line">   public void setApplicationEventPublisher (ApplicationEventPublisher publisher) &#123;</span><br><span class="line">      this.publisher = publisher;</span><br><span class="line">   &#125;</span><br><span class="line">   public void publish() &#123;</span><br><span class="line">      CustomEvent ce = new CustomEvent(this);</span><br><span class="line">      publisher.publishEvent(ce);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义事件监听处理类，实现ApplicationListener<customevent></customevent></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class CustomEventHandler implements ApplicationListener&lt;CustomEvent&gt; &#123;</span><br><span class="line">   public void onApplicationEvent(CustomEvent event) &#123;</span><br><span class="line">      System.out.println(event.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ConfigurableApplicationContext context = </span><br><span class="line">         new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">	  </span><br><span class="line">      CustomEventPublisher cvp = </span><br><span class="line">         (CustomEventPublisher) context.getBean(&quot;customEventPublisher&quot;);</span><br><span class="line">      </span><br><span class="line">      cvp.publish();  </span><br><span class="line">      cvp.publish();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Beans.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = &quot;customEventHandler&quot; class = &quot;com.tutorialspoint.CustomEventHandler&quot;/&gt;</span><br><span class="line">   &lt;bean id = &quot;customEventPublisher&quot; class = &quot;com.tutorialspoint.CustomEventPublisher&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>注意不要忘记添加customEventHandler,虽然在主函数中没有直接使用，但是context需要检查实现了ApplicationListener的<br>bean,所以需要在xml文件中，添加该bean。</p>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my Custom Event</span><br><span class="line">my Custom Event</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/13/Spring入门学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/13/Spring入门学习笔记/" itemprop="url">
                  Spring入门学习笔记（2）——基于Java的配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-13 22:41:10 / 修改时间：22:41:55" itemprop="dateCreated datePublished" datetime="2018-10-13T22:41:10+08:00">2018-10-13</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/13/Spring入门学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/13/Spring入门学习笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/13/Spring入门学习笔记/" class="leancloud_visitors" data-flag-title="Spring入门学习笔记（2）——基于Java的配置">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于Java的配置"><a href="#基于Java的配置" class="headerlink" title="基于Java的配置"></a>基于Java的配置</h2><h3 id="Configuration-amp-Bean-Annotations"><a href="#Configuration-amp-Bean-Annotations" class="headerlink" title="@Configuration &amp; @Bean Annotations"></a>@Configuration &amp; @Bean Annotations</h3><p>使用@Configuration注释类表示，Spring IoC容器可以将该类用作bean定义的源。@Bean注释告诉Spring，用@Bean注释的方法将返回一个应该在Spring应用程序上下文中注册为bean的对象。最简单的@Configuration类如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.tutorialspoint;</span><br><span class="line">import org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class HelloWorldConfig &#123;</span><br><span class="line">   @Bean </span><br><span class="line">   public HelloWorld helloWorld()&#123;</span><br><span class="line">      return new HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它和以下的XML方式定义的是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id = &quot;helloWorld&quot; class = &quot;com.tutorialspoint.HelloWorld&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>带@Bean的方法名作为bean id注释，他创建并返回实际的bean。一个配置类可以拥有多个Bean的声明。一旦定义了配置类，你可以通过 <code>AnnotationConfigApplicationContex</code>加载并获取<br>他们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class);</span><br><span class="line">   </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">   helloWorld.setMessage(&quot;Hello World!&quot;);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以获取加载不同的configuration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.register(AdditionalConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line"></span><br><span class="line">   MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>HelloWorldConfig.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class HelloWorldConfig &#123;</span><br><span class="line">   @Bean </span><br><span class="line">   public HelloWorld helloWorld()&#123;</span><br><span class="line">      return new HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloWorld.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">   private String message;</span><br><span class="line"></span><br><span class="line">   public void setMessage(String message)&#123;</span><br><span class="line">      this.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage()&#123;</span><br><span class="line">      System.out.println(&quot;Your Message : &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext ctx = </span><br><span class="line">         new AnnotationConfigApplicationContext(HelloWorldConfig.class);</span><br><span class="line">   </span><br><span class="line">      HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">      helloWorld.setMessage(&quot;Hello World!&quot;);</span><br><span class="line">      helloWorld.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Message : Hello World!</span><br></pre></td></tr></table></figure>
<h3 id="注入Bean依赖"><a href="#注入Bean依赖" class="headerlink" title="注入Bean依赖"></a>注入Bean依赖</h3><p>当@ bean相互依赖时，表示依赖关系就像让一个bean方法调用另一个bean一样简单，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Foo foo() &#123;</span><br><span class="line">        return new Foo(bar());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public Bar bar() &#123;</span><br><span class="line">        return new Bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo bean通过构造函数注入接收到bar的引用</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>TextEditorConfig.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TextEditorConfig &#123;</span><br><span class="line">   @Bean </span><br><span class="line">   public TextEditor textEditor()&#123;</span><br><span class="line">      return new TextEditor( spellChecker() );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean </span><br><span class="line">   public SpellChecker spellChecker()&#123;</span><br><span class="line">      return new SpellChecker( );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TextEditor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">   private SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line">   public TextEditor(SpellChecker spellChecker)&#123;</span><br><span class="line">      System.out.println(&quot;Inside TextEditor constructor.&quot; );</span><br><span class="line">      this.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   public void spellCheck()&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpellChecker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SpellChecker &#123;</span><br><span class="line">   public SpellChecker()&#123;</span><br><span class="line">      System.out.println(&quot;Inside SpellChecker constructor.&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">   public void checkSpelling()&#123;</span><br><span class="line">      System.out.println(&quot;Inside checkSpelling.&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext ctx = </span><br><span class="line">         new AnnotationConfigApplicationContext(TextEditorConfig.class);</span><br><span class="line"></span><br><span class="line">      TextEditor te = ctx.getBean(TextEditor.class);</span><br><span class="line">      te.spellCheck();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside SpellChecker constructor.</span><br><span class="line">Inside TextEditor constructor.</span><br><span class="line">Inside checkSpelling.</span><br></pre></td></tr></table></figure>
<h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><p><code>@Import</code>注解允许在一个Configuration中导入另外一个配置类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   public A a() &#123;</span><br><span class="line">      return new A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   public B a() &#123;</span><br><span class="line">      return new A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，只需要加载ConfigB，则可以加载A，B两个配置文件，而不需要一样加载两次.</p>
<h3 id="Lifecycle-Callbacks（声明周期回调）"><a href="#Lifecycle-Callbacks（声明周期回调）" class="headerlink" title="Lifecycle Callbacks（声明周期回调）"></a>Lifecycle Callbacks（声明周期回调）</h3><p>@bean注释支持指定任意的初始化和销毁回调方法,就像Spring XML的init方法和销毁方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">   public void init() &#123;</span><br><span class="line">      // initialization logic</span><br><span class="line">   &#125;</span><br><span class="line">   public void cleanup() &#123;</span><br><span class="line">      // destruction logic</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot; )</span><br><span class="line">   public Foo foo() &#123;</span><br><span class="line">      return new Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定Bean的作用域"><a href="#指定Bean的作用域" class="headerlink" title="指定Bean的作用域"></a>指定Bean的作用域</h3><p>默认作用域是singleton，可以通过以下方法重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   @Scope(&quot;prototype&quot;)</span><br><span class="line">   public Foo foo() &#123;</span><br><span class="line">      return new Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/Vesta发号器学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/Vesta发号器学习记录/" itemprop="url">
                  Vesta发号器学习记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-12 01:41:09" itemprop="dateCreated datePublished" datetime="2018-10-12T01:41:09+08:00">2018-10-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-14 22:07:38" itemprop="dateModified" datetime="2018-10-14T22:07:38+08:00">2018-10-14</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/12/Vesta发号器学习记录/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/12/Vesta发号器学习记录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/12/Vesta发号器学习记录/" class="leancloud_visitors" data-flag-title="Vesta发号器学习记录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目源码：<a href="https://gitee.com/robertleepeak/vesta-id-generator" target="_blank" rel="noopener">gitee仓库</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>发号器是：</p>
<ul>
<li>分布式服务化系统不可或缺的基础设施之一</li>
<li>保证系统正确运行和高可用</li>
</ul>
<p>UUID问题：</p>
<ul>
<li>能保证ID的唯一性，无法满足其他特性<ul>
<li>时间粗略有序性</li>
<li>可反解性</li>
<li>可制造性</li>
</ul>
</li>
<li>使用完全的时间数据，性能低</li>
<li>UUID长，占用空间大，数据库性能下降</li>
<li>UUID不具备有序性，会产生随机写入，insert会占用很多时间</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/11/kclient源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/11/kclient源码解读/" itemprop="url">
                  kclient源码解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-11 23:27:55" itemprop="dateCreated datePublished" datetime="2018-10-11T23:27:55+08:00">2018-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-14 22:08:01" itemprop="dateModified" datetime="2018-10-14T22:08:01+08:00">2018-10-14</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/11/kclient源码解读/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/11/kclient源码解读/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/11/kclient源码解读/" class="leancloud_visitors" data-flag-title="kclient源码解读">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="kclient消息中间件"><a href="#kclient消息中间件" class="headerlink" title="kclient消息中间件"></a>kclient消息中间件</h1><p>从使用角度上开始入手学习</p>
<h2 id="kclient-processor"><a href="#kclient-processor" class="headerlink" title="kclient-processor"></a>kclient-processor</h2><p>该项目使用springboot调用kclient库，程序目录如下:</p>
<ul>
<li>domain<ul>
<li>Cat ： 定义了一个cat对象</li>
<li>Dog ： 定义了一个Dog对象</li>
</ul>
</li>
<li>handler ： 消息处理器<ul>
<li>AnimalsHandler ： 定义了Cat和Dog的具体行为</li>
</ul>
</li>
<li>KClientApplication.java ： Spring boot的主函数——程序执行入口</li>
<li>KClientController.java : Controller 文件</li>
</ul>
<h3 id="top-ninwoo-kclient-app-KClientApplication"><a href="#top-ninwoo-kclient-app-KClientApplication" class="headerlink" title="top.ninwoo.kclient.app.KClientApplication"></a>top.ninwoo.kclient.app.KClientApplication</h3><p>1.启动Spring Boot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctxBackend = SpringApplication.run(</span><br><span class="line">                KClientApplication.class, args);</span><br></pre></td></tr></table></figure>
<p>2.启动程序后将自动加载KClientController(@RestController)</p>
<h3 id="top-ninwoo-kclient-app-KClientController"><a href="#top-ninwoo-kclient-app-KClientController" class="headerlink" title="top.ninwoo.kclient.app.KClientController"></a>top.ninwoo.kclient.app.KClientController</h3><p>1.通过@RestController，使@SpringBootApplication,可以自动加载该Controller</p>
<p>2.通过<code>kafka-application.xml</code>加载Beans</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private ApplicationContext ctxKafkaProcessor =</span><br><span class="line">            new ClassPathXmlApplicationContext(&quot;kafka-application.xml&quot;);</span><br></pre></td></tr></table></figure>
<p><code>kafka-application.xml</code>声明了一个kclient bean，并设置其初始化执行<code>init</code>方法，具体实现见下章具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;kClientBoot&quot; class=&quot;top.ninwoo.kafka.kclient.boot.KClientBoot&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>另外声明了一个扫描消息处理器的bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;top.ninwoo.kclient.app.handler&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>具体内容在下一节介绍</p>
<ol start="3">
<li>使用<code>@RequestMapping</code>定义<code>/</code>,<code>/status</code>,<code>/stop</code>,<code>/restart</code>定义了不同的接口</li>
</ol>
<p>这些接口实现比较简单，需要注意的是他们调用的<code>getKClientBoot()</code>函数。</p>
<p>上文，我们已经通过xml中，添加了两个Bean，调用Bean的具体实现方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private KClientBoot getKClientBoot() &#123;</span><br><span class="line">       return (KClientBoot) ctxKafkaProcessor.getBean(&quot;kClientBoot&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过Bean获取到KClient获取到了KClientBoot对象，便可以调用其具体方法。</p>
<h3 id="top-ninwoo-kclient-app-handler-AnimalsHandler"><a href="#top-ninwoo-kclient-app-handler-AnimalsHandler" class="headerlink" title="top.ninwoo.kclient.app.handler.AnimalsHandler"></a>top.ninwoo.kclient.app.handler.AnimalsHandler</h3><p>消息处理函数</p>
<p>1.使用<code>@KafkaHandlers</code>进行声明bean，关于其具体实现及介绍在具体实现中进行介绍</p>
<p>2.定义了三个处理函数</p>
<ul>
<li>dogHandler</li>
<li>catHandler</li>
<li>ioExceptionHandler</li>
</ul>
<p><strong>dogHandler</strong></p>
<p>具体处理很简单，主要分析@InputConsumer和@Consumer的作用，具体实现将在后续进行介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@InputConsumer(propertiesFile = &quot;kafka-consumer.properties&quot;, topic = &quot;test&quot;, streamNum = 1)</span><br><span class="line">   @OutputProducer(propertiesFile = &quot;kafka-producer.properties&quot;, defaultTopic = &quot;test1&quot;)</span><br><span class="line">   public Cat dogHandler(Dog dog) &#123;</span><br><span class="line">       System.out.println(&quot;Annotated dogHandler handles: &quot; + dog);</span><br><span class="line"></span><br><span class="line">       return new Cat(dog);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@InputConsumer</code>根据输入参数定义了一个Consumer，通过该Consumer传递具体值给dog，作为该处理函数的<br>输入。</li>
<li><code>@OutputProducer</code>根据输入参数定义一个Producer，而该处理函数最后返回的Cat对象，将通过该Producer最终传递到Kafka中</li>
</ul>
<p>以下的功能与上述相同，唯一需要注意的是 <code>@InputConsumer</code>和<code>@OutputProducer</code>可以单独存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@InputConsumer(propertiesFile = &quot;kafka-consumer.properties&quot;, topic = &quot;test1&quot;, streamNum = 1)</span><br><span class="line">    public void catHandler(Cat cat) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;Annotated catHandler handles: &quot; + cat);</span><br><span class="line"></span><br><span class="line">        throw new IOException(&quot;Man made exception.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ErrorHandler(exception = IOException.class, topic = &quot;test1&quot;)</span><br><span class="line">    public void ioExceptionHandler(IOException e, String message) &#123;</span><br><span class="line">        System.out.println(&quot;Annotated excepHandler handles: &quot; + e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="top-ninwoo-kclient-app-domain"><a href="#top-ninwoo-kclient-app-domain" class="headerlink" title="top.ninwoo.kclient.app.domain"></a>top.ninwoo.kclient.app.domain</h3><p>只是定义了Cat和Dog对象，不做赘述。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，总结下我们都实现了哪些功能？</p>
<ol>
<li>程序启动</li>
<li>调用KClientBoot.init()方法</li>
<li>AnimalsHandler定义了消费者和生产者的具体方法。</li>
</ol>
<h2 id="kclient-core"><a href="#kclient-core" class="headerlink" title="kclient-core"></a>kclient-core</h2><p>kclient消息中间件的主体部分，该部分将会涉及</p>
<ul>
<li>kafka基本操作</li>
<li>反射</li>
</ul>
<p>项目结构如下:</p>
<ul>
<li>boot <ul>
<li>ErrorHandler </li>
<li>InputConsumer</li>
<li>OutputProducer</li>
<li>KafkaHandlers</li>
<li>KClientBoot</li>
<li>KafkaHandler</li>
<li>KafkaHandlerMeta</li>
</ul>
</li>
<li>core<ul>
<li>KafkaConsumer</li>
<li>KafkaProducer</li>
</ul>
</li>
<li>excephandler<ul>
<li>DefaultExceptionHandler</li>
<li>ExceptionHandler</li>
</ul>
</li>
<li>handlers<ul>
<li>BeanMessageHandler</li>
<li>BeansMessageHandler</li>
<li>DocumentMessageHandler</li>
<li>ObjectMessageHandler</li>
<li>ObjectsMessageHandler</li>
<li>MessageHandler</li>
<li>SafelyMessageHandler</li>
</ul>
</li>
<li>reflection.util<ul>
<li>AnnotationHandler</li>
<li>AnnotationTranversor</li>
<li>TranversorContext</li>
</ul>
</li>
</ul>
<p>在接下来的源码阅读中，我将按照程序执行的顺序进行解读。如果其中涉及到没有讨论过的模块，读者可以向下翻阅。这么<br>做的唯一原因，为了保证思维的连续性，尽可能不被繁杂的程序打乱。</p>
<h3 id="top-ninwoo-kafka-kclient-boot-KClientBoot"><a href="#top-ninwoo-kafka-kclient-boot-KClientBoot" class="headerlink" title="top.ninwoo.kafka.kclient.boot.KClientBoot"></a>top.ninwoo.kafka.kclient.boot.KClientBoot</h3><p>如果读者刚刚阅读上一章节，那么可能记得，我们注册了一个kClientBoot的bean，并设置了初始化函数init(),所以，在kclient源码的阅读中<br>，我们将从该文件入手，开始解读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">       meta = getKafkaHandlerMeta();</span><br><span class="line"></span><br><span class="line">       if (meta.size() == 0)</span><br><span class="line">           throw new IllegalArgumentException(</span><br><span class="line">                   &quot;No handler method is declared in this spring context.&quot;);</span><br><span class="line"></span><br><span class="line">       for (final KafkaHandlerMeta kafkaHandlerMeta : meta) &#123;</span><br><span class="line">           createKafkaHandler(kafkaHandlerMeta);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>1.该函数，首先获取了一个HandlerMeta，我们可以简单理解，在这个数据元中，存储了全部的Handler信息，这个Handler信息指的是上一章节中通过<code>@KafkaHandlers</code>定义的处理函数，<br>具体实现见<code>top.ninwoo.kafka.kclient.boot.KafkaHandlerMeta</code>。</p>
<p>2.获取数据元之后，通过循环，创建对应的处理函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (final KafkaHandlerMeta kafkaHandlerMeta : meta) &#123;</span><br><span class="line">           createKafkaHandler(kafkaHandlerMeta);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>3.getKafkaHandlerMeta函数的具体实现</p>
<p>a.通过applicationContext获取包含kafkaHandlers注解的Bean名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] kafkaHandlerBeanNames = applicationContext</span><br><span class="line">    .getBeanNamesForAnnotation(KafkaHandlers.class);</span><br></pre></td></tr></table></figure>
<p>b.通过BeanName获取到Bean对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object kafkaHandlerBean = applicationContext</span><br><span class="line">       .getBean(kafkaHandlerBeanName);</span><br><span class="line">   Class&lt;? extends Object&gt; kafkaHandlerBeanClazz = kafkaHandlerBean</span><br><span class="line">       .getClass();</span><br></pre></td></tr></table></figure>
<p>c.构建mapData数据结构,具体构建见<code>top.ninwoo.kafka.kclient.reflection.util.AnnotationTranversor</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Class&lt;? extends Annotation&gt;, Map&lt;Method, Annotation&gt;&gt; mapData = extractAnnotationMaps(kafkaHandlerBeanClazz);</span><br></pre></td></tr></table></figure>
<p>d.map转数据元并添加到数据元meta list中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta.addAll(convertAnnotationMaps2Meta(mapData, kafkaHandlerBean));</span><br></pre></td></tr></table></figure>
<p>4.循环遍历创建kafkaHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (final KafkaHandlerMeta kafkaHandlerMeta : meta) &#123;</span><br><span class="line">           createKafkaHandler(kafkaHandlerMeta);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="createKafkaHandler-函数的具体实现："><a href="#createKafkaHandler-函数的具体实现：" class="headerlink" title="createKafkaHandler()函数的具体实现："></a>createKafkaHandler()函数的具体实现：</h4><p>a.通过meta获取clazz中的参数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends Object&gt; paramClazz = kafkaHandlerMeta</span><br><span class="line">    .getParameterType()</span><br></pre></td></tr></table></figure>
<p>b.创建kafkaProducer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KafkaProducer kafkaProducer = createProducer(kafkaHandlerMeta);</span><br></pre></td></tr></table></figure></p>
<p>c.创建ExceptionHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ExceptionHandler&gt; excepHandlers = createExceptionHandlers(kafkaHandlerMeta);</span><br></pre></td></tr></table></figure>
<p>d.根据clazz的参数类型，选择消息转换函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MessageHandler beanMessageHandler = null;</span><br><span class="line">       if (paramClazz.isAssignableFrom(JSONObject.class)) &#123;</span><br><span class="line">           beanMessageHandler = createObjectHandler(kafkaHandlerMeta,</span><br><span class="line">                   kafkaProducer, excepHandlers);</span><br><span class="line">       &#125; else if (paramClazz.isAssignableFrom(JSONArray.class)) &#123;</span><br><span class="line">           beanMessageHandler = createObjectsHandler(kafkaHandlerMeta,</span><br><span class="line">                   kafkaProducer, excepHandlers);</span><br><span class="line">       &#125; else if (List.class.isAssignableFrom(Document.class)) &#123;</span><br><span class="line">           beanMessageHandler = createDocumentHandler(kafkaHandlerMeta,</span><br><span class="line">                   kafkaProducer, excepHandlers);</span><br><span class="line">       &#125; else if (List.class.isAssignableFrom(paramClazz)) &#123;</span><br><span class="line">           beanMessageHandler = createBeansHandler(kafkaHandlerMeta,</span><br><span class="line">                   kafkaProducer, excepHandlers);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           beanMessageHandler = createBeanHandler(kafkaHandlerMeta,</span><br><span class="line">                   kafkaProducer, excepHandlers);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>e.创建kafkaConsumer,并启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KafkaConsumer kafkaConsumer = createConsumer(kafkaHandlerMeta,</span><br><span class="line">        beanMessageHandler);</span><br><span class="line">kafkaConsumer.startup();</span><br></pre></td></tr></table></figure>
<p>f.创建KafkaHanlder,并添加到列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KafkaHandler kafkaHandler = new KafkaHandler(kafkaConsumer,</span><br><span class="line">        kafkaProducer, excepHandlers, kafkaHandlerMeta);</span><br><span class="line"></span><br><span class="line">kafkaHandlers.add(kafkaHandler);</span><br></pre></td></tr></table></figure>
<h4 id="createExceptionHandlers的具体实现"><a href="#createExceptionHandlers的具体实现" class="headerlink" title="createExceptionHandlers的具体实现"></a>createExceptionHandlers的具体实现</h4><p>1.创建一个异常处理列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ExceptionHandler&gt; excepHandlers = new ArrayList&lt;ExceptionHandler&gt;();</span><br></pre></td></tr></table></figure>
<p>2.从kafkaHandlerMeta获取异常处理的注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (final Map.Entry&lt;ErrorHandler, Method&gt; errorHandler : kafkaHandlerMeta</span><br><span class="line">    .getErrorHandlers().entrySet()) &#123;</span><br></pre></td></tr></table></figure>
<p>3.创建一个异常处理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExceptionHandler exceptionHandler = new ExceptionHandler() &#123;</span><br><span class="line">    public boolean support(Throwable t) &#123;&#125;</span><br><span class="line">	public void handle(Throwable t, String message) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="support方法判断异常类型是否和输入相同"><a href="#support方法判断异常类型是否和输入相同" class="headerlink" title="support方法判断异常类型是否和输入相同"></a>support方法判断异常类型是否和输入相同</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean support(Throwable t) &#123;</span><br><span class="line">       // We handle the exception when the classes are exactly same</span><br><span class="line">       return errorHandler.getKey().exception() == t.getClass();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="handler方法，进一步对异常进行处理"><a href="#handler方法，进一步对异常进行处理" class="headerlink" title="handler方法，进一步对异常进行处理"></a>handler方法，进一步对异常进行处理</h5><p>1.获取异常处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method excepHandlerMethod = errorHandler.getValue();</span><br></pre></td></tr></table></figure>
<p>2.使用Method.invoke执行异常处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">excepHandlerMethod.invoke(kafkaHandlerMeta.getBean(),</span><br><span class="line">                   t, message);</span><br></pre></td></tr></table></figure>
<p>这里用到了一些反射原理，以下对invoke做简单介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj,</span><br><span class="line">                     Object... args)</span><br><span class="line">              throws IllegalAccessException,</span><br><span class="line">                     IllegalArgumentException,</span><br><span class="line">                     InvocationTargetException</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>obj 从底层方法被调用的对象</li>
<li>args 用于方法的参数</li>
</ul>
<p>在该项目中的实际情况如下：</p>
<p>Method实际对应<code>top.ninwoo.kclient.app.handler.AnimalsHandler</code>中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ErrorHandler(exception = IOException.class, topic = &quot;test1&quot;)</span><br><span class="line">   public void ioExceptionHandler(IOException e, String message) &#123;</span><br><span class="line">       System.out.println(&quot;Annotated excepHandler handles: &quot; + e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>参数方面：</p>
<ul>
<li>kafkaHandlerMeta.getBean() ： AninmalsHandler</li>
<li>t</li>
<li>message</li>
</ul>
<p>invoke完成之后，将会执行ioExceptionHandler函数</p>
<hr>
<p>4.添加异常处理到列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">excepHandlers.add(exceptionHandler);</span><br></pre></td></tr></table></figure>
<h3 id="createObjectHandler"><a href="#createObjectHandler" class="headerlink" title="createObjectHandler"></a>createObjectHandler</h3><h3 id="createObjectsHandler"><a href="#createObjectsHandler" class="headerlink" title="createObjectsHandler"></a>createObjectsHandler</h3><h3 id="createDocumentHandler"><a href="#createDocumentHandler" class="headerlink" title="createDocumentHandler"></a>createDocumentHandler</h3><h3 id="createBeanHandler"><a href="#createBeanHandler" class="headerlink" title="createBeanHandler"></a>createBeanHandler</h3><h3 id="createBeansHandler"><a href="#createBeansHandler" class="headerlink" title="createBeansHandler"></a>createBeansHandler</h3><p>以上均实现了类似的功能，只是创建了不同类型的对象，然后重写了不同的执行函数。</p>
<p>实现原理和异常处理相同，底层都是调用了invoke函数，通过反射机制启动了对应的函数。</p>
<p>下一节对此做了详细介绍</p>
<h3 id="invokeHandler"><a href="#invokeHandler" class="headerlink" title="invokeHandler"></a>invokeHandler</h3><p>1.获取对应Method方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method kafkaHandlerMethod = kafkaHandlerMeta.getMethod();</span><br></pre></td></tr></table></figure>
<p>2.执行接收返回结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object result = kafkaHandlerMethod.invoke(</span><br><span class="line">    kafkaHandlerMeta.getBean(), parameter);</span><br></pre></td></tr></table></figure>
<p>3.如果生产者非空，意味着需要通过生产者程序将结果发送到Kafka中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (kafkaProducer != null) &#123;</span><br><span class="line">    if (result instanceof JSONObject)</span><br><span class="line">        kafkaProducer.send(((JSONObject) result).toJSONString());</span><br><span class="line">    else if (result instanceof JSONArray)</span><br><span class="line">        kafkaProducer.send(((JSONArray) result).toJSONString());</span><br><span class="line">    else if (result instanceof Document)</span><br><span class="line">        kafkaProducer.send(((Document) result).getTextContent());</span><br><span class="line">    else</span><br><span class="line">        kafkaProducer.send(JSON.toJSONString(result));</span><br></pre></td></tr></table></figure>
<h3 id="生产者和消费者创建方法"><a href="#生产者和消费者创建方法" class="headerlink" title="生产者和消费者创建方法"></a>生产者和消费者创建方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   protected KafkaConsumer createConsumer(</span><br><span class="line">           final KafkaHandlerMeta kafkaHandlerMeta,</span><br><span class="line">           MessageHandler beanMessageHandler) &#123;</span><br><span class="line">       KafkaConsumer kafkaConsumer = null;</span><br><span class="line"></span><br><span class="line">       if (kafkaHandlerMeta.getInputConsumer().fixedThreadNum() &gt; 0) &#123;</span><br><span class="line">           kafkaConsumer = new KafkaConsumer(kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().propertiesFile(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().topic(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().streamNum(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().fixedThreadNum(), beanMessageHandler);</span><br><span class="line"></span><br><span class="line">       &#125; else if (kafkaHandlerMeta.getInputConsumer().maxThreadNum() &gt; 0</span><br><span class="line">               &amp;&amp; kafkaHandlerMeta.getInputConsumer().minThreadNum() &lt; kafkaHandlerMeta</span><br><span class="line">               .getInputConsumer().maxThreadNum()) &#123;</span><br><span class="line">           kafkaConsumer = new KafkaConsumer(kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().propertiesFile(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().topic(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().streamNum(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().minThreadNum(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().maxThreadNum(), beanMessageHandler);</span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           kafkaConsumer = new KafkaConsumer(kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().propertiesFile(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().topic(), kafkaHandlerMeta</span><br><span class="line">                   .getInputConsumer().streamNum(), beanMessageHandler);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return kafkaConsumer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected KafkaProducer createProducer(</span><br><span class="line">           final KafkaHandlerMeta kafkaHandlerMeta) &#123;</span><br><span class="line">       KafkaProducer kafkaProducer = null;</span><br><span class="line"></span><br><span class="line">       if (kafkaHandlerMeta.getOutputProducer() != null) &#123;</span><br><span class="line">           kafkaProducer = new KafkaProducer(kafkaHandlerMeta</span><br><span class="line">                   .getOutputProducer().propertiesFile(), kafkaHandlerMeta</span><br><span class="line">                   .getOutputProducer().defaultTopic());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // It may return null</span><br><span class="line">       return kafkaProducer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这两部分比较简单，不做赘述。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>KClientBoot.java实现了：</p>
<ul>
<li>获取使用KafkaHandlers中定义注释的方法及其它信息</li>
<li>基于反射机制，生成处理函数。</li>
<li>执行处理函数</li>
<li>创建对应Producer和Consumer</li>
</ul>
<p>还剩余几个比较简单的部分，比如shutdownAll()等方法，将在具体实现处进行补充介绍。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/11/Spring学习文档/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/11/Spring学习文档/" itemprop="url">
                  Spring入门学习笔记（1）——基于XML的配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-11 23:16:58" itemprop="dateCreated datePublished" datetime="2018-10-11T23:16:58+08:00">2018-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-14 22:06:59" itemprop="dateModified" datetime="2018-10-14T22:06:59+08:00">2018-10-14</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/11/Spring学习文档/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/11/Spring学习文档/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/11/Spring学习文档/" class="leancloud_visitors" data-flag-title="Spring入门学习笔记（1）——基于XML的配置">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>该篇随笔，主要用于记录Spring Framework 基础知识。由于笔者是初学者，见识与能力有限，难免出现错误，如果发现错误，望不吝赐教。</p>
<h2 id="Spring好处"><a href="#Spring好处" class="headerlink" title="Spring好处"></a>Spring好处</h2><p>以下列出了使用Spring Framework的一些巨大好处 </p>
<ul>
<li><p>Spring使开发人员能够使用POJO开发企业级应用程序。仅使用POJO的好处是您不需要EJB容器产品（如应用程序服务器），但您可以选择仅使用强大的servlet容器（如Tomcat）或某些商业产品。</p>
</li>
<li><p>Spring采用模块化方式组织。即使包和类的数量很大，你也只需要担心你需要的那些而忽略其余的。</p>
</li>
<li><p>Spring并没有重新发明轮子，而是真正利用了一些现有技术，如几个ORM框架，日志框架，JEE，Quartz和JDK计时器以及其他视图技术。</p>
</li>
<li><p>测试用Spring编写的应用程序很简单，因为依赖于环境的代码被移动到这个框架中。此外，通过使用JavaBeanstyle POJO，使用依赖注入来注入测试数据变得更加容易。</p>
</li>
<li><p>Spring的Web框架是一个设计良好的Web MVC框架，它提供了一个很好的替代Web框架，如Struts或其他过度设计或不太流行的Web框架。</p>
</li>
<li><p>Spring提供了一个方便的API，用于将特定于技术的异常（例如，JDBC，Hibernate或JDO抛出）转换为一致的，未经检查的异常。</p>
</li>
<li><p>轻量级IoC容器往往是轻量级的，尤其是与EJB容器相比时。这有利于在具有有限内存和CPU资源的计算机上开发和部署应用程序。</p>
</li>
<li><p>Spring提供了一致的事务管理接口，可以缩小到本地事务（例如，使用单个数据库）并扩展到全局事务（例如，使用JTA）。</p>
</li>
</ul>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul>
<li>Inversion of Control</li>
<li>编写java程序，尽可能独立于其他java类，增加重用这些类的可能性</li>
<li>含义：A依赖于B类，意味着，B类将由IoC注入A类</li>
</ul>
<h2 id="面向面编程（AOP）"><a href="#面向面编程（AOP）" class="headerlink" title="面向面编程（AOP）"></a>面向面编程（AOP）</h2><ul>
<li>关键组件</li>
<li>跨领域问题：日志记录，声明式事务，安全性，缓存等</li>
<li>AOP中，模块化单元是面</li>
<li>AOP可帮助您将交叉问题与它们所影响的对象分离</li>
<li>允许定义方法拦截器和切入点，以便解耦。</li>
</ul>
<h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><h3 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h3><ul>
<li>Beans<ul>
<li>Core,提供了框架的基本部分，包括IOC和依赖注入特征</li>
<li>Bean提供了BeanFactory,复杂的实现工厂模式</li>
<li>Context由core和bean提供，它是访问任何定义和配置的对象的媒介。ApplicationContext接口是上下文模块的焦点。</li>
<li>SpEL模块提供了一种强大的表达式语言，用于在运行时查询和操作对象图。<h3 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h3></li>
</ul>
</li>
<li>JDBC</li>
<li>ORM 模块为流行的对象关系映射api提供集成层，包括JPA、JDO、Hibernate和iBatis</li>
<li>OXM 模块提供了一个抽象层，支持JAXB、Castor、XMLBeans、JiBX和XStream的对象/XML映射实现。</li>
<li>JMS 包含用于生成和消费消息的特性。</li>
<li>Transaction 模块为实现特殊接口的类和所有pojo支持编程和声明式事务管理</li>
</ul>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul>
<li>Web Web模块提供了基本的面向Web的集成特性，例如多部分文件上传功能，以及使用servlet侦听器和面向Web的应用程序上下文初始化IoC容器。</li>
<li>Web-MVC 模块包含Spring用于web应用程序的模型-视图-控制器(MVC)实现。</li>
<li>Web-Socket 模块在web应用程序中支持基于websocket的客户机和服务器之间的双向通信。</li>
<li>Web-Portlet 模块提供了在portlet环境中使用的MVC实现，并反映了web servlet模块的功能。</li>
</ul>
<h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><ul>
<li>AOP模块提供了面向方面的编程实现，允许您将方法拦截器和切入点定义为实现应该分离的功能的干净解耦代码。</li>
<li>Aspects模块提供了与AspectJ的集成，这又是一个强大而成熟的AOP框架。</li>
<li>Instrumentation 模块提供了类插装支持和类装入器实现，用于某些应用服务器。</li>
<li>Messaging模块支持STOMP作为应用程序中使用的WebSocket子协议。它还支持一个注释编程模型，用于路由和处理来自WebSocket客户端的STOMP消息。</li>
<li>Test模块支持使用JUnit或TestNG框架测试Spring组件</li>
</ul>
<h2 id="编写第一个程序"><a href="#编写第一个程序" class="headerlink" title="编写第一个程序"></a>编写第一个程序</h2><p>1.使用IDEA创建Spring项目<br>2.创建HelloWorld文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package top.ninwoo.learn;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public void getMessage() &#123;</span><br><span class="line">        System.out.println(&quot;Your message &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.创建Main函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">        HelloWorld obj = (HelloWorld) context.getBean(&quot;helloworld&quot;);</span><br><span class="line">        obj.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用ClassPathXmlApplicationContext读取bean配置文件</p>
<p>4.配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloworld&quot; class=&quot;top.ninwoo.learn.HelloWorld&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>property 传入了HelloWorld的参数</p>
<h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><ul>
<li>Spring Framework的核心</li>
<li>容器船舰对象，并连接彼此，并管理其生命周期</li>
<li>DI来管理组成应用程序的组件</li>
<li>对象称为Spring Beans</li>
</ul>
<p>Spring IoC容器利用Java POJO类和配置元数据来生成完全配置和可执行的系统或应用程序，配置元数据可以由：</p>
<ul>
<li>XML</li>
<li>Java注释或Java代码表示</li>
</ul>
<p>容器类型：</p>
<ul>
<li>Spring BeanFactory： 最简单容器，目的向后兼容与Spring集成的大量第三方框架</li>
<li>Spring ApplicationContext: 添加了更多企业特有的功能，比如能够解析来自属性文件的文本消息，<br>以及能够向感兴趣的事件侦听器发布应用程序事件。</li>
</ul>
<p>ApplicationContext包含全部的BeanFactory，BeanFactory在小型化设备上仍可以用。</p>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><p>构成应用程序主干并由Spring IoC容器管理的对象称为bean.</p>
<p>Bean的定义：</p>
<ul>
<li>如何创建Bean</li>
<li>Bean的生命周期细节</li>
<li>Bean的依赖关系</li>
</ul>
<p>参数：</p>
<ol>
<li>class ：必须，指定创建的Bean类</li>
<li>name ： 唯一指定Bean标识符，XML中可以使用id/name来指定</li>
<li>scope ： 作用域</li>
<li>construtor-arg ： 用于注入依赖项</li>
<li>properties ： 用于注入依赖项</li>
<li>autowiring mode ： 用于注入依赖项</li>
<li>lazy-initialization mode ： 延迟初始化的bean告诉IoC容器在第一次请求时创建bean实例，而不是在启动时创建</li>
<li>initialization method ： 在容器设置了bean之后所有必要属性之后调用的回调。它将在bean生命周期章节中讨论</li>
<li>destruction method ： 当Bean容器被销毁时使用的回调。</li>
</ol>
<h3 id="Spring配置元数据"><a href="#Spring配置元数据" class="headerlink" title="Spring配置元数据"></a>Spring配置元数据</h3><p>方法：</p>
<ul>
<li>XML</li>
<li>注解</li>
<li>Java的配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- A simple bean definition --&gt;</span><br><span class="line">   &lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- A bean definition with lazy init set on --&gt;</span><br><span class="line">   &lt;bean id = &quot;...&quot; class = &quot;...&quot; lazy-init = &quot;true&quot;&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- A bean definition with initialization method --&gt;</span><br><span class="line">   &lt;bean id = &quot;...&quot; class = &quot;...&quot; init-method = &quot;...&quot;&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- A bean definition with destruction method --&gt;</span><br><span class="line">   &lt;bean id = &quot;...&quot; class = &quot;...&quot; destroy-method = &quot;...&quot;&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- more bean definitions go here --&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Bean-Scopes"><a href="#Spring-Bean-Scopes" class="headerlink" title="Spring - Bean Scopes"></a>Spring - Bean Scopes</h2><p>当定义一个<bean>时，可以指定一个作用域。比如<code>prototype</code>可以强制Spring每次都产生一个新的Bean实例,<code>singleton</code>每次返回的都是同一个bean。</bean></p>
<p>Spring Framework 支持以下5种作用域，如果使用的是web-aware Application只有三种可用。</p>
<ul>
<li>singleton : 将bean定义范围限定为每个Spring IoC容器的单个实例（默认）</li>
<li>prototype : 将bean定义范围限定为具有任意数量的对象实例</li>
<li>request : 将bean定义范围限定为HTTP请求。仅在Web感知Spring ApplicationContext的上下文中有效</li>
<li>session : 将bean定义范围限定为HTTP会话。仅在Web感知Spring ApplicationContext的上下文中有效。</li>
<li>global-session : 将bean定义范围限定为全局HTTP会话。仅在Web感知Spring ApplicationContext的上下文中有效。</li>
</ul>
<h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><p>只创建该Bean定义的对象的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A bean definition with singleton scope --&gt;</span><br><span class="line">&lt;bean id = &quot;...&quot; class = &quot;...&quot; scope = &quot;singleton&quot;&gt;</span><br><span class="line">   &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>配置完成之后，如下的代码，有以下的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">HelloWorld objA = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line"></span><br><span class="line">objA.setMessage(&quot;I&apos;m object A&quot;);</span><br><span class="line">objA.getMessage();</span><br><span class="line"></span><br><span class="line">HelloWorld objB = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">objB.getMessage();</span><br></pre></td></tr></table></figure>
<p>该程序打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m object A</span><br><span class="line">I&apos;m object A</span><br></pre></td></tr></table></figure>
<p>这证明，实际只创建了一个bean对象，虽然调用了两次getBean，但返回的都是同一个对象。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每次调用bean，都会创建一个新的方法。</p>
<p>将上述的bean设置为prototype，执行同样的代码将会出现不同的效果。</p>
<p>该程序打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m object A</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Bean-Life-Cycle"><a href="#Spring-Bean-Life-Cycle" class="headerlink" title="Spring-Bean Life Cycle"></a>Spring-Bean Life Cycle</h2><p>主要指的是，当bean被实例化时，可能需要执行一些初始化以使其进入可用状态。类似地，当不再需要bean并从容器中移除bean时，可能需要进行一些清理。</p>
<p>中间也存在一些活动，本章重点讨论以下两个声明周期回调方法。</p>
<ul>
<li>initmethod</li>
<li>destroy-method</li>
</ul>
<h3 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h3><p>org.springframework.beans.factory.InitializingBean已经为我们提供了开发接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void afterPropertiesSet() throws Exception;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过实现上面的接口实现初始化工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean implements InitializingBean &#123;</span><br><span class="line">   public void afterPropertiesSet() &#123;</span><br><span class="line">      // do some initialization work</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于XML的配置元数据，可以通过init-method指定具有void无参数的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;exampleBean&quot; class = &quot;examples.ExampleBean&quot; init-method = &quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h3><p>org.springframework.beans.factory.DisposableBean也已经提供好了接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void destroy() throws Exception;</span><br></pre></td></tr></table></figure>
<p>这样，我们可以通过实现该接口实现销毁的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean implements DisposableBean &#123;</span><br><span class="line">   public void destroy() &#123;</span><br><span class="line">      // do some destruction work</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果想要使该函数起作用，需要注册registerShutdownHook()方法。</p>
<p>同样，基于XML配置元数据，可以使用destroy-method指定具有void的无参方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;exampleBean&quot; class = &quot;examples.ExampleBean&quot; destroy-method = &quot;destroy&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>建议还是使用XML的方式，更加灵活。</p>
<h3 id="默认的初始化和销毁方法"><a href="#默认的初始化和销毁方法" class="headerlink" title="默认的初始化和销毁方法"></a>默认的初始化和销毁方法</h3><p>如果很多bean都需要同名的初始化和销毁方法，可以在<beans>配置default-init-method和<br>default-destroy-method。</beans></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span><br><span class="line">   default-init-method = &quot;init&quot; </span><br><span class="line">   default-destroy-method = &quot;destroy&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;</span><br><span class="line">      &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Bean-Post-Processors"><a href="#Spring-Bean-Post-Processors" class="headerlink" title="Spring - Bean Post Processors"></a>Spring - Bean Post Processors</h2><p>BeanPostProcessor接口定义了可以实现的回调方法，以提供您自己的实例化逻辑、依赖性解析逻辑等等。您还可以在Spring容器通过插入一个或多个BeanPostProcessor实现完成bean的实例化、配置和初始化之后实现一些定制逻辑。</p>
<p>可以配置多个BeanPostProcessor接口，还可以通过设置BeanPostProcessor实现有序接口所提供的order属性来控制这些BeanPostProcessor接口的执行顺序。</p>
<p>BeanPostProcessor对bean(或对象)实例进行操作，这意味着Spring IoC容器实例化一个bean实例，然后BeanPostProcessor接口执行它们的工作。</p>
<p>ApplicationContext自动检测任何通过BeanPostProcessor接口的实现定义的bean，并将这些bean注册为postprocessor，然后在bean创建时由容器适当地调用。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>HelloWorld.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">   private String message;</span><br><span class="line"></span><br><span class="line">   public void setMessage(String message)&#123;</span><br><span class="line">      this.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage()&#123;</span><br><span class="line">      System.out.println(&quot;Your Message : &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">   public void init()&#123;</span><br><span class="line">      System.out.println(&quot;Bean is going through init.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public void destroy()&#123;</span><br><span class="line">      System.out.println(&quot;Bean will destroy now.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InitHelloWorld.java——实现BeanPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line"></span><br><span class="line">public class InitHelloWorld implements BeanPostProcessor &#123;</span><br><span class="line">   public Object postProcessBeforeInitialization(Object bean, String beanName) </span><br><span class="line">      throws BeansException &#123;</span><br><span class="line">      </span><br><span class="line">      System.out.println(&quot;BeforeInitialization : &quot; + beanName);</span><br><span class="line">      return bean;  // you can return any other object as well</span><br><span class="line">   &#125;</span><br><span class="line">   public Object postProcessAfterInitialization(Object bean, String beanName) </span><br><span class="line">      throws BeansException &#123;</span><br><span class="line">      </span><br><span class="line">      System.out.println(&quot;AfterInitialization : &quot; + beanName);</span><br><span class="line">      return bean;  // you can return any other object as well</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainAPP.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">      context.registerShutdownHook();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Beans.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = &quot;helloWorld&quot; class = &quot;com.tutorialspoint.HelloWorld&quot;</span><br><span class="line">      init-method = &quot;init&quot; destroy-method = &quot;destroy&quot;&gt;</span><br><span class="line">      &lt;property name = &quot;message&quot; value = &quot;Hello World!&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean class = &quot;com.tutorialspoint.InitHelloWorld&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeforeInitialization : helloWorld</span><br><span class="line">Bean is going through init.</span><br><span class="line">AfterInitialization : helloWorld</span><br><span class="line">Your Message : Hello World!</span><br><span class="line">Bean will destroy now.</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Bean-Definition-Inheritance-Bean的定义继承"><a href="#Spring-Bean-Definition-Inheritance-Bean的定义继承" class="headerlink" title="Spring - Bean Definition Inheritance(Bean的定义继承)"></a>Spring - Bean Definition Inheritance(Bean的定义继承)</h2><p>Spring Bean的继承和Java类的继承没有关系，但是概念相同。可以将父Bean定义为模板，其他子bean从父bean继承所需配置。</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>Beans.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id = &quot;helloWorld&quot; class = &quot;com.tutorialspoint.HelloWorld&quot;&gt;</span><br><span class="line">      &lt;property name = &quot;message1&quot; value = &quot;Hello World!&quot;/&gt;</span><br><span class="line">      &lt;property name = &quot;message2&quot; value = &quot;Hello Second World!&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id =&quot;helloIndia&quot; class = &quot;com.tutorialspoint.HelloIndia&quot; parent = &quot;helloWorld&quot;&gt;</span><br><span class="line">      &lt;property name = &quot;message1&quot; value = &quot;Hello India!&quot;/&gt;</span><br><span class="line">      &lt;property name = &quot;message3&quot; value = &quot;Namaste India!&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>HelloWorld.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">   private String message1;</span><br><span class="line">   private String message2;</span><br><span class="line"></span><br><span class="line">   public void setMessage1(String message)&#123;</span><br><span class="line">      this.message1 = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setMessage2(String message)&#123;</span><br><span class="line">      this.message2 = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage1()&#123;</span><br><span class="line">      System.out.println(&quot;World Message1 : &quot; + message1);</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage2()&#123;</span><br><span class="line">      System.out.println(&quot;World Message2 : &quot; + message2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloIndia.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class HelloIndia &#123;</span><br><span class="line">   private String message1;</span><br><span class="line">   private String message2;</span><br><span class="line">   private String message3;</span><br><span class="line"></span><br><span class="line">   public void setMessage1(String message)&#123;</span><br><span class="line">      this.message1 = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setMessage2(String message)&#123;</span><br><span class="line">      this.message2 = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setMessage3(String message)&#123;</span><br><span class="line">      this.message3 = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage1()&#123;</span><br><span class="line">      System.out.println(&quot;India Message1 : &quot; + message1);</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage2()&#123;</span><br><span class="line">      System.out.println(&quot;India Message2 : &quot; + message2);</span><br><span class="line">   &#125;</span><br><span class="line">   public void getMessage3()&#123;</span><br><span class="line">      System.out.println(&quot;India Message3 : &quot; + message3);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">      </span><br><span class="line">      HelloWorld objA = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">      objA.getMessage1();</span><br><span class="line">      objA.getMessage2();</span><br><span class="line"></span><br><span class="line">      HelloIndia objB = (HelloIndia) context.getBean(&quot;helloIndia&quot;);</span><br><span class="line">      objB.getMessage1();</span><br><span class="line">      objB.getMessage2();</span><br><span class="line">      objB.getMessage3();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">World Message1 : Hello World!</span><br><span class="line">World Message2 : Hello Second World!</span><br><span class="line">India Message1 : Hello India!</span><br><span class="line">India Message2 : Hello Second World!</span><br><span class="line">India Message3 : Namaste India!</span><br></pre></td></tr></table></figure>
<p>由此可以看出，虽然</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id =&quot;helloIndia&quot; class = &quot;com.tutorialspoint.HelloIndia&quot; parent = &quot;helloWorld&quot;&gt;</span><br><span class="line">      &lt;property name = &quot;message1&quot; value = &quot;Hello India!&quot;/&gt;</span><br><span class="line">      &lt;property name = &quot;message3&quot; value = &quot;Namaste India!&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>没有给message2复制，但是将父bean的message2的值传递给了子bean的message2。</p>
<p>总结来说，子Bean存在则覆盖，没有则继承父类的定义。</p>
<h2 id="注入集合"><a href="#注入集合" class="headerlink" title="注入集合"></a>注入集合</h2><p>本小结主要讲述如何使用XML注入集合</p>
<p>可以注入的类型如下：</p>
<ul>
<li><code>&lt;list&gt;</code></li>
<li><code>&lt;set&gt;</code></li>
<li><code>&lt;map&gt;</code></li>
<li><code>&lt;props&gt;</code></li>
</ul>
<p>你可以使用<list>或<set>来连接Collection或Array。</set></list></p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>JavaCollection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JavaCollection &#123;</span><br><span class="line">   List addressList;</span><br><span class="line">   Set  addressSet;</span><br><span class="line">   Map  addressMap;</span><br><span class="line">   Properties addressProp;</span><br><span class="line"></span><br><span class="line">   // a setter method to set List</span><br><span class="line">   public void setAddressList(List addressList) &#123;</span><br><span class="line">      this.addressList = addressList;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // prints and returns all the elements of the list.</span><br><span class="line">   public List getAddressList() &#123;</span><br><span class="line">      System.out.println(&quot;List Elements :&quot;  + addressList);</span><br><span class="line">      return addressList;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // a setter method to set Set</span><br><span class="line">   public void setAddressSet(Set addressSet) &#123;</span><br><span class="line">      this.addressSet = addressSet;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // prints and returns all the elements of the Set.</span><br><span class="line">   public Set getAddressSet() &#123;</span><br><span class="line">      System.out.println(&quot;Set Elements :&quot;  + addressSet);</span><br><span class="line">      return addressSet;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // a setter method to set Map</span><br><span class="line">   public void setAddressMap(Map addressMap) &#123;</span><br><span class="line">      this.addressMap = addressMap;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // prints and returns all the elements of the Map.</span><br><span class="line">   public Map getAddressMap() &#123;</span><br><span class="line">      System.out.println(&quot;Map Elements :&quot;  + addressMap);</span><br><span class="line">      return addressMap;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // a setter method to set Property</span><br><span class="line">   public void setAddressProp(Properties addressProp) &#123;</span><br><span class="line">      this.addressProp = addressProp;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // prints and returns all the elements of the Property.</span><br><span class="line">   public Properties getAddressProp() &#123;</span><br><span class="line">      System.out.println(&quot;Property Elements :&quot;  + addressProp);</span><br><span class="line">      return addressProp;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainApp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">      JavaCollection jc=(JavaCollection)context.getBean(&quot;javaCollection&quot;);</span><br><span class="line"></span><br><span class="line">      jc.getAddressList();</span><br><span class="line">      jc.getAddressSet();</span><br><span class="line">      jc.getAddressMap();</span><br><span class="line">      jc.getAddressProp();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Beans.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Definition for javaCollection --&gt;</span><br><span class="line">   &lt;bean id = &quot;javaCollection&quot; class = &quot;com.tutorialspoint.JavaCollection&quot;&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- results in a setAddressList(java.util.List) call --&gt;</span><br><span class="line">      &lt;property name = &quot;addressList&quot;&gt;</span><br><span class="line">         &lt;list&gt;</span><br><span class="line">            &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">         &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressSet(java.util.Set) call --&gt;</span><br><span class="line">      &lt;property name = &quot;addressSet&quot;&gt;</span><br><span class="line">         &lt;set&gt;</span><br><span class="line">            &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">         &lt;/set&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressMap(java.util.Map) call --&gt;</span><br><span class="line">      &lt;property name = &quot;addressMap&quot;&gt;</span><br><span class="line">         &lt;map&gt;</span><br><span class="line">            &lt;entry key = &quot;1&quot; value = &quot;INDIA&quot;/&gt;</span><br><span class="line">            &lt;entry key = &quot;2&quot; value = &quot;Pakistan&quot;/&gt;</span><br><span class="line">            &lt;entry key = &quot;3&quot; value = &quot;USA&quot;/&gt;</span><br><span class="line">            &lt;entry key = &quot;4&quot; value = &quot;USA&quot;/&gt;</span><br><span class="line">         &lt;/map&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- results in a setAddressProp(java.util.Properties) call --&gt;</span><br><span class="line">      &lt;property name = &quot;addressProp&quot;&gt;</span><br><span class="line">         &lt;props&gt;</span><br><span class="line">            &lt;prop key = &quot;one&quot;&gt;INDIA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key = &quot;one&quot;&gt;INDIA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key = &quot;two&quot;&gt;Pakistan&lt;/prop&gt;</span><br><span class="line">            &lt;prop key = &quot;three&quot;&gt;USA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key = &quot;four&quot;&gt;USA&lt;/prop&gt;</span><br><span class="line">         &lt;/props&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List Elements :[INDIA, Pakistan, USA, USA] </span><br><span class="line">Set Elements :[INDIA, Pakistan, USA] </span><br><span class="line">ap Elements :&#123;1 = INDIA, 2 = Pakistan, 3 = USA, 4 = USA&#125; </span><br><span class="line">Property Elements :&#123;two = Pakistan, one = INDIA, three = USA, four = USA&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入Bean引用"><a href="#注入Bean引用" class="headerlink" title="注入Bean引用"></a>注入Bean引用</h3><p>可以直接注入bean引用作为集合的元素之一。</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Bean Definition to handle references and values --&gt;</span><br><span class="line">   &lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- Passing bean reference  for java.util.List --&gt;</span><br><span class="line">      &lt;property name = &quot;addressList&quot;&gt;</span><br><span class="line">         &lt;list&gt;</span><br><span class="line">            &lt;ref bean = &quot;address1&quot;/&gt;</span><br><span class="line">            &lt;ref bean = &quot;address2&quot;/&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">         &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- Passing bean reference  for java.util.Set --&gt;</span><br><span class="line">      &lt;property name = &quot;addressSet&quot;&gt;</span><br><span class="line">         &lt;set&gt;</span><br><span class="line">            &lt;ref bean = &quot;address1&quot;/&gt;</span><br><span class="line">            &lt;ref bean = &quot;address2&quot;/&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">         &lt;/set&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- Passing bean reference  for java.util.Map --&gt;</span><br><span class="line">      &lt;property name = &quot;addressMap&quot;&gt;</span><br><span class="line">         &lt;map&gt;</span><br><span class="line">            &lt;entry key = &quot;one&quot; value = &quot;INDIA&quot;/&gt;</span><br><span class="line">            &lt;entry key = &quot;two&quot; value-ref = &quot;address1&quot;/&gt;</span><br><span class="line">            &lt;entry key = &quot;three&quot; value-ref = &quot;address2&quot;/&gt;</span><br><span class="line">         &lt;/map&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>注入空值和空的字符串</p>
<p>1.传入空的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;...&quot; class = &quot;exampleBean&quot;&gt;</span><br><span class="line">   &lt;property name = &quot;email&quot; value = &quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>2.传入null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;...&quot; class = &quot;exampleBean&quot;&gt;</span><br><span class="line">   &lt;property name = &quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Beans-Auto-Wiring-Bean自动装配）"><a href="#Spring-Beans-Auto-Wiring-Bean自动装配）" class="headerlink" title="Spring-Beans Auto-Wiring(Bean自动装配）"></a>Spring-Beans Auto-Wiring(Bean自动装配）</h2><p>Spring container可以自动连接协作bean之间的关系，而不需要使用<constructor-arg>和<property>.</property></constructor-arg></p>
<h3 id="自动装配模式"><a href="#自动装配模式" class="headerlink" title="自动装配模式"></a>自动装配模式</h3><p>您可以使用<bean>元素的autowire属性为bean定义指定autowire模式。</bean></p>
<ul>
<li>no : 默认设置，不自动装配，需要配置显示bean引用连接</li>
<li>byName ： 通过属性名称自动装配。Spring容器查看在XML配置文件中将autowire属性设置为byName的bean的属性。然后，它尝试将其属性与配置文件中相同名称定义的bean匹配并连接起来。</li>
<li>byType ： 按属性数据类型自动连接。Spring容器查看在XML配置文件中将autowire属性设置为byType的bean的属性。然后，如果其类型与配置文件中的某个bean名称完全匹配，则尝试匹配并连接属性。如果存在多个这样的bean，则抛出一个致命异常。</li>
<li>constructor ： 类似于byType，但类型应用于构造函数参数。如果容器中没有确切的构造函数参数类型的bean，则会引发致命错误。</li>
<li>autodetect ： Spring首先尝试通过使用构造函数进行连接，如果它不工作，Spring将尝试通过byType进行自动连接。</li>
</ul>
<p>可以使用<code>byType</code>和<code>constructor</code>自动装配模式去装配arrays和其他的集合类型。</p>
<h3 id="自动装配的限制"><a href="#自动装配的限制" class="headerlink" title="自动装配的限制"></a>自动装配的限制</h3><p>自动装配在项目中一致使用时效果最好。如果通常不使用自动装配的话，对开发者只使用一两个bean定义的情况，会比较困惑。但是，autowiring可以显著减少指定属性或构造函数参数的需要，但是在使用它们之前，应该考虑到autowiring的局限性和缺点。</p>
<p>限制：</p>
<ul>
<li>重写可能性</li>
</ul>
<p>您仍然可以使用和 settings来指定依赖关系，这些设置总是会覆盖autowiring。</p>
<ul>
<li>原始数据类型</li>
</ul>
<p>您不能自动连接所谓的简单属性，如原语、字符串和类。</p>
<ul>
<li>混乱</li>
</ul>
<p>不如显式装配精确，所以如果可能，最好使用显式装配。</p>
<h2 id="基于注释的配置"><a href="#基于注释的配置" class="headerlink" title="基于注释的配置"></a>基于注释的配置</h2><p>从Spring 2.5起，支持使用注解进行配置依赖注入。因此，您可以通过在相关的类、方法或字段声明上使用注释将bean配置移动到组件类本身，而不是使用XML来描述bean连接。</p>
<p>注释注入在XML注入之前执行。因此，对于通过两种方法连接的属性，后一种配置将覆盖前一种配置。</p>
<p>默认情况下，在Spring容器中没有打开注释连接。因此，在使用基于注释的连接之前，我们需要在Spring配置文件中启用它。因此，如果您想在Spring应用程序中使用任何注释，请考虑以下配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xmlns:context = &quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">   http://www.springframework.org/schema/context</span><br><span class="line">   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;context:annotation-config/&gt;</span><br><span class="line">   &lt;!-- bean definitions go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>一旦<code>&lt;context:annotation-config/&gt;</code>被配置，您可以开始对代码进行注释，以指示Spring应该自动将值连接到属性、方法和构造函数。让我们看看一些重要的注释，了解它们是如何工作的：</p>
<ul>
<li>Required : @Required注释应用于bean属性setter方法。</li>
<li>Autowired : @Autowired注释可以应用于bean属性setter方法、非设置方法、构造函数和属性。</li>
<li>Qualifier : 与@Autowired一起使用@Qualifier注释可以通过指定连接哪个bean来消除混淆。</li>
<li>JSR-250 Annotations : Spring支持基于JSR-250的注释，包括@Resource、@PostConstruct和@PreDestroy注释。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Joliu">
      <meta itemprop="description" content="研究生不研究“生”，开始研究代码了！">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NinWoo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-28 17:45:41" itemprop="dateCreated datePublished" datetime="2018-09-28T17:45:41+08:00">2018-09-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-12 19:23:32" itemprop="dateModified" datetime="2018-09-12T19:23:32+08:00">2018-09-12</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/28/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/09/28/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/09/28/hello-world/" class="leancloud_visitors" data-flag-title="Hello World">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Joliu</p>
              <p class="site-description motion-element" itemprop="description">研究生不研究“生”，开始研究代码了！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Ninwoo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:ljo0412@live.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
		  	<br>
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=433103172&auto=1&height=66"></iframe>
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joliu</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'PNtkm1hqPMXTv6z3WHs2viCJ-gzGzoHsz',
        appKey: 'Fl29iwRhiNINjJwOHA613D9d',
        placeholder: 'Just go go',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  





  

  
  <script>
    
    function showTime(Counter) {
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { "$in": entries } }) })
        .done(function ({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log("LeanCloud Counter Error: " + responseJSON.code + " " + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "PNtkm1hqPMXTv6z3WHs2viCJ-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "PNtkm1hqPMXTv6z3WHs2viCJ-gzGzoHsz",
                'X-LC-Key': "Fl29iwRhiNINjJwOHA613D9d",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          if ($('.post-title-link').length >= 1) {
            showTime(Counter);
          }
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
